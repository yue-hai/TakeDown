# 一、数据结构和算法概述

## 1、数据结构和算法的关系

1. 数据结构(data structure)是一门研究组织数据方式的学科，有了编程语言也就有了数据结构，学好数据结构可以编写出更加漂亮、更加有效率的代码。
2. 要学习好数据结构就要多多考虑如何将生活中遇到的问题，用程序去实现解决
3. 程序 = 数据结构 + 算法
4. 数据结构是算法的基础，换言之，想要学好算法，需要把数据结构学到位。

## 2、线性结构和非线性结构

> 数据结构包括：线性结构和非线性结构。

### ①、线性结构

1. 线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系
2. 线性结构有两种不同的存储结构，即顺序存储结构(数组)和链式存储结构(链表)。
	1. 顺序存储的线性表称为顺序表，顺序表中的存储元素地址是连续的
	2. 链式存储的线性表称为链表，链表中的存储元素地址不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息
3. 线性结构常见的有：数组、队列、链表和栈

### ②、非线性结构

1. 非线性结构包括：二维数组、多维数组、广义表、树结构、图结构

# 二、稀疏数组和队列

## 1、稀疏 sparsearray 数组

### ①、先看一个实际的需求

1. 编写的五子棋程序中，有存盘退出和续上盘的功能。

![|700](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240617092634.png)

2. 分析问题：因为该二维数组的很多值是默认值 0，因此记录了很多没有意义的数据 -> 稀疏数组

### ②、基本介绍

1. 当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。稀疏数组的处理方法是：
2. 记录数组一共有几行几列，有多少个不同的值
3. 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模

![|675](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240617093316.png)

### ③、主要作用和意义

1. **节省存储空间**：
	1. 在很多应用中，如数学中的矩阵运算或图像处理等，数据结构中可能包含大量的零值。如果使用常规的二维数组来存储这样的数据，会消耗大量的存储空间来存储这些零值。
	2. 稀疏数组通过只存储非零数据和其位置，显著减少了所需的存储空间。
2. **提高数据处理效率**：
	1. 对于包含大量零值的数据集，常规的数据处理方法（如遍历整个数组进行计算）会浪费大量的计算资源在零值上。
	2. 稀疏数组只存储和处理非零元素，从而提高了数据处理过程的效率，减少了不必要的计算。
3. **便于数据操作**：
	1. 在某些操作中，如矩阵的加法、乘法等，如果矩阵是稀疏的，那么使用稀疏数组可以使得这些操作更为简便和快速。
	2. 只对非零元素进行操作可以显著减少计算量，特别是在涉及大型数据集的情况下。
4. **广泛的应用场景**，稀疏数组在多个领域都有应用，例如：
	1. 科学计算：在物理、工程和生物信息学等领域的计算中常常会遇到大规模的稀疏矩阵。
	2. 推荐系统：在处理用户-项目评分矩阵时，由于大部分用户只对极少数项目进行评分，因此评分矩阵通常是高度稀疏的。
	3. 网络分析：在图论中，节点的连接性通常是稀疏的，使用稀疏数组可以有效地存储和处理图数据。
	4. 自然语言处理：在处理词频或词向量时，由于词汇量庞大而实际使用频率并不高，数据结构往往是稀疏的。
5. **优化内存使用**
	1. 在内存受限的系统中，如嵌入式系统或移动设备，使用稀疏数组可以优化内存使用，使得应用能够在这些设备上更加高效地运行。
6. 总之，稀疏数组通过对数据进行有效的压缩和优化处理，不仅节约了存储空间，还提高了数据处理的效率，特别是在处理大规模数据集时更显其优势。

### ④、应用实例

1. 使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)
2. 把稀疏数组存盘，并且可以从新恢复原来的二维数组数
3. 整体思路分析：
4. 原始二维数组转稀疏数组的思路：
	1. 遍历原始的二维数组，得到有效数据的个数 `sum`
	2. 根据 `sum` 就可以创建稀疏数组 `sparseArr int[sum+1][3]`
	3. 将二维数组的有效数据数据存入到稀疏数组
5. 稀疏数组转原始的二维数组的思路：
	1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的 `chessArr2=int[11][11]`
	2. 在读取稀疏数组后几行的数据，并赋给原始的二维数组即可

![|700](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240617101623.png)

### ⑤、代码实现：原始二维数组转稀疏数组

```java
package com.yuehai._01_sparseArrayAndQueue._01_sparseArray;

/**
 * 原始二维数组转稀疏数组
 * @author 月海
 * @date 2024/6/17 10:22
 * @description 原始二维数组转稀疏数组
 */
public class _01_ArrayToSparseArray {
    public static void main(String[] args) {
        // 创建一个原始的二维数组 11 * 11；0: 表示没有棋子， 1 表示 黑子 2 表蓝子
        int[][] originalArray = new int[11][11];
        originalArray[1][2] = 1;
        originalArray[2][3] = 2;
        originalArray[4][5] = 2;
        
        // 输出原始的二维数组
        System.out.println("---- 原始的二维数组 ----------------");
        for (int[] row : originalArray) {
            for (int data : row) {
                System.out.printf("%d\t", data);
            }
            System.out.println();
        }
        
        // 非 0 数据的个数
        int sum = 0;
        // 遍历原始数组，得到非 0 数据的个数
        for (int[] row : originalArray) {
            for (int data : row) {
                if (data != 0) {
                    sum++;
                }
            }
        }
        
        // 创建对应的稀疏数组
        int[][] sparseArray = new int[sum + 1][3];
        // 给稀疏数组赋值：第一行，第一列，原始数组的总行数
        sparseArray[0][0] = originalArray.length;
        // 给稀疏数组赋值：第一行，第二列，原始数组的总列数
        sparseArray[0][1] = originalArray[0].length;
        // 给稀疏数组赋值：第一行，第三列，非 0 数据的个数
        sparseArray[0][2] = sum;
        
        // 创建一个变量，用于记录是第几个非 0 数据
        int count = 0;
        
        // 遍历原始数组，将非 0 数据存入稀疏数组
        for (int row = 0; row < originalArray.length; row++){
            for(int column = 0; column < originalArray[0].length; column++){
                // 如果是非 0 数据，存入稀疏数组
                if (originalArray[row][column] != 0) {
                    count++;
                    sparseArray[count][0] = row;
                    sparseArray[count][1] = column;
                    sparseArray[count][2] = originalArray[row][column];
                }
            }
        }
        
        // 输出稀疏数组
        System.out.println("---- 稀疏数组 ----------------");
        for (int[] row : sparseArray) {
            for (int data : row) {
                System.out.printf("%d\t", data);
            }
            System.out.println();
        }
    }
    
}
```

### ⑥、代码实现：稀疏数组转原始的二维数组

```java
package com.yuehai._01_sparseArrayAndQueue._01_sparseArray;

/**
 * 稀疏数组转原始二维数组
 * @author 月海
 * @date 2024/6/17 10:59
 * @description 稀疏数组转原始二维数组
 */
public class _02_SparseArrayToArray {
    public static void main(String[] args) {
        // 创建一个稀疏数组
        int[][] sparseArray = new int[4][3];
        // 给稀疏数组赋值；第一行，原始数组的总行数、总列数、非 0 数据的个数
        sparseArray[0][0] = 11;
        sparseArray[0][1] = 11;
        sparseArray[0][2] = 3;
        // 给稀疏数组赋值：第一个非 0 数据的行、列、值
        sparseArray[1][0] = 1;
        sparseArray[1][1] = 2;
        sparseArray[1][2] = 1;
        // 给稀疏数组赋值：第二个非 0 数据的行、列、值
        sparseArray[2][0] = 2;
        sparseArray[2][1] = 3;
        sparseArray[2][2] = 2;
        // 给稀疏数组赋值：第三个非 0 数据的行、列、值
        sparseArray[3][0] = 4;
        sparseArray[3][1] = 5;
        sparseArray[3][2] = 2;
        
        // 输出稀疏数组
        System.out.println("---- 稀疏数组 ----------------");
        for (int[] row : sparseArray) {
            for (int data : row) {
                System.out.printf("%d\t", data);
            }
            System.out.println();
        }
        
        // 创建一个原始的二维数组
        int[][] originalArray = new int[sparseArray[0][0]][sparseArray[0][1]];
        // 遍历稀疏数组，将非 0 数据存入原始数组
        for(int row = 1; row < sparseArray.length; row++){
            // 行数
            int x = sparseArray[row][0];
            // 列数
            int y = sparseArray[row][1];
            // 设置值
            originalArray[x][y] = sparseArray[row][2];
        }
        
        // 输出原始的二维数组
        System.out.println("---- 原始的二维数组 ----------------");
        for (int[] row : originalArray) {
            for (int data : row) {
                System.out.printf("%d\t", data);
            }
            System.out.println();
        }
    }
}
```

## 2、队列

### ①、队列的一个使用场景

1. 银行排队的案例：

![|507](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240617123937.png)

### ②、队列介绍

1. 队列是一个有序列表，可以用数组或是链表来实现。
2. 遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出
3. 示意图：(使用数组模拟队列示意图)

![|546](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240617124009.png)

### ③、主要作用和意义

1. **异步数据处理**：队列常用于处理异步数据，如多线程或网络应用中的任务调度。数据可以在一个地方被添加到队列中，并在另一个地方被移除和处理，从而允许异步或并行处理数据。这是实现生产者-消费者模型的基础。
2. **资源共享管理**：在资源管理中，队列帮助管理和调度有限资源的使用，如打印机作业管理或 CPU 任务调度。资源请求以它们到达的顺序被处理，确保了公平性和效率。
3. **操作系统**：在操作系统中，队列被广泛用于进程管理和网络通信。例如，操作系统可能会使用多个队列来管理不同优先级的进程或管理 I/O 请求。
4. **数据流管理**：在数据流应用和网络流量控制中，队列可以用来平衡负载和控制数据包的发送，防止网络拥塞。这包括使用队列来实现各种网络调度算法。
5. **顺序处理**：队列提供了一种保持元素处理顺序的方法。在需要按顺序处理数据的场景中，如在客户服务中按顺序响应客户请求，或在电子商务中处理订单，队列都非常有用。
6. **缓冲作用**：队列可以作为缓冲区，平衡生产速度和消费速度的不匹配。这在多种应用中非常关键，比如在流媒体中缓冲数据，确保视频或音频播放的连续性。
7. **事件驱动编程**：在事件驱动的编程和应用中，如图形用户界面（GUI）或游戏开发中，事件（如鼠标点击或键盘事件）可以被加入到队列中，按照它们发生的顺序依次处理。
8. **通信和同步**：在分布式系统中，队列用于实现各种通信和同步机制，帮助不同系统组件有效协作。这些队列可能存在于内存中，或者通过更复杂的消息队列系统（如RabbitMQ, Kafka等）实现跨网络的消息传递。
9. 总结来说，队列作为一种基础且功能强大的数据结构，它的设计哲学——先进先出，解决了多种程序设计和系统运行中的基本问题，特别是在需要顺序、公平或效率地处理数据和任务的场景中。

### ④、数组模拟队列思路

1. 队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图，其中 `maxSize` 是该队列的最大容量。
2. 因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 `front` 及 `rear` 分别记录队列前后端的下标，`front` 会随着数据输出而改变，而 `rear` 则是随着数据输入而改变，如图所示:

![|546](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240617124009.png)

3. 当我们将数据存入队列时称为 `addQueue`，`addQueue` 的处理需要有两个步骤：
	1. 将尾指针往后移：`rear+1` , 当 `front == rear` 【空】
	2. 若尾指针 `rear` 小于队列的最大下标 `maxSize-1`，则将数据存入 `rear` 所指的数组元素中，否则无法存入数据。`rear == maxSize - 1[队列满]`
4. 问题分析并优化：
	1. 目前数组使用一次就不能用， 没有达到复用的效果
	2. 将这个数组使用算法，改进成一个环形的队列，取模：%

### ⑤、代码实现：数组模拟队列

```java
package com.yuehai._01_sparseArrayAndQueue._02_queue;

import java.util.Scanner;

/**
 * 数组模拟队列
 * @author 月海
 * @date 2024/6/17 13:08
 * @description 数组模拟队列
 */
public class _01_ArraySimulationQueue {
    
    /**
     * 队列头，指向当前队列的第一个元素的前一个位置，初始值为 -1，操作时需要先移动指针再操作数组
     * 若是设置为 0，那么取出数据时，需要先取出数据再移动指针
     */
    private int front = -1;
    
    /**
     * 队列尾，指向当前队列的最后一个元素的前一个位置，初始值为 -1，操作时需要先移动指针再操作数组
     * 若是设置为 0，那么添加数据时，需要先移动指针再添加数据
     */
    private int rear = -1;
    
    /**
     * 队列的最大容量
     */
    private final int maxSize;
    
    /**
     * 数组
     */
    private final int[] arr;
    
    /**
     * 构造方法
     * @param maxSize 队列的最大容量
     */
    public _01_ArraySimulationQueue(int maxSize) {
        this.maxSize = maxSize;
        this.arr = new int[maxSize];
    }
    
    /**
     * 向队列中添加数据
     */
    public void addQueue(int n) {
        if (rear + 1 >= maxSize){
            throw new RuntimeException("队列已满，不能添加数据");
        }
        
        // 队列尾后移
        rear++;
        arr[rear] = n;
        System.out.println("添加数据：" + n + "，队列尾：" + rear);
        
    }
    
    /**
     * 从队列中取出数据
     */
    public void getQueue() {
        // 检查队列是否为空
        if (front == rear) {
            throw new RuntimeException("队列为空");
        }
        
        // 队列头后移
        front++;
        // 取出数据
        int returnDate = arr[front];
        System.out.println("取出数据：" + returnDate + "，队列头：" + front);
        
        // 取出数据后，将取出的数据置为 0
        arr[front] = 0;
    }
    
    public static void main(String[] args) {
        // 实例化对象
        _01_ArraySimulationQueue queue = new _01_ArraySimulationQueue(3);
        // 创建Scanner对象，用于接收键盘输入
        Scanner scanner = new Scanner(System.in);
        
        // 循环操作
        while (true){
            System.out.println("请选择操作：\n1 - 添加元素\n2 - 取出元素\n3 - 退出程序");
            // 读取输入的选项
            int choice = scanner.nextInt();
            
            // 根据输入的选项执行操作
            switch (choice) {
                case 1:
                    System.out.println("请输入要添加的元素：");
                    // 读取输入的元素
                    int num = scanner.nextInt();
                    try {
                        queue.addQueue(num);
                    } catch (RuntimeException e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case 2:
                    try {
                        queue.getQueue();
                    } catch (RuntimeException e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case 3:
                    // 关闭 Scanner 对象
                    scanner.close();
                    // 结束程序
                    return;
                default:
                    System.out.println("无效输入，请重新选择！");
                    break;
            }
            
            System.out.println();
            // 输出当前队列
            System.out.print("当前队列为：");
            for (int i : queue.arr) {
                System.out.print(i + " ");
            }
            System.out.println();
            System.out.println("队列头：" + queue.front + "，队列尾：" + queue.rear);
            
            System.out.println("--------------------------");
        }
    }
    
}
```

### ⑥、优化：数组模拟环形队列

1. 对前面的数组模拟队列的优化，充分利用数组。因此将数组看做是一个环形的。(通过取模的方式来实现即可)
2. 分析说明：
	1. 尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定，这个在做判断队列满的时候需要注意 `(rear + 1) % maxSize == front`：表示队列满
	2. `rear == front`：表示队列空
3. 分析示意图：

![|546](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240617124009.png)

### ⑦、环形队列思路

1. `front` 变量的含义做一个调整：`front` 指向队列的第一个元素，也就是说 `arr[front]` 就是队列的第一个元素，`front` 的初始值设置为 `0`
2. `rear` 变量的含义做一个调整：`rear` 指向队列的最后一个元素的后一个位置，因为希望<font color="#ff0000">空出一个空间</font>，所以 `rear` 指向空出的这一个空间，`rear` 的初始值设置为 `0`
3. <font color="#ff0000">队列满时条件是</font>，： `(rear + 1) % maxSize == front`：如果 `rear` 指针的下一个位置正好是 `front` 指针的位置，这表示整个数组已被填满，没有更多的空间来添加新的元素（空出了一个空间）。
	1. 因为 `front` 是第一个元素，如果 `rear + 1` 回到了 `front` 的位置，说明在 `front` 之前（数组的环形结构中的“最后”部分）没有空间可以使用
	2. 为了实现这种循环效果，取模运算（%）可以确保 `rear` 指针在达到数组的最大索引后可以回到数组的开头
4. <font color="#ff0000">队列为空的条件是</font>：`rear == front`
5. 为什么需要空出一个位置：
	1. 如果不空出一个位置：
		1. 当 `rear == front` 时，这可以表示队列为空
		2. 但如果允许 `rear` 完全追上 `front`，同样的条件 `front == rear` 也会在队列实际上满时成立，这就产生了歧义。
	2. 因此，空出一个位置可以明确地区分这两种状态，从而使得队列的管理变得更加高效和清晰。
6. <font color="#ff0000">队列中有效的数据的个数</font>：`(rear + maxSize - front) % maxSize` ：
	1. `rear - front`：直接给出了从 `front` 到 `rear` 的距离差，但若 `rear` 索引小于 `front` 索引，结果为负。
	2. `+ maxSize`：加上 `maxSize` 是为了防止上述情况下结果为负数，确保总是得到一个正数。
	3. `% maxSize`：取模确保结果不会超过数组的最大长度，这对环形结构至关重要，因为它保证了即使 `rear - front + maxSize` 超过了 `maxSize`，结果仍然会被限制在 0 到 maxSize - 1 的范围内，即绝对值

```
// 先通过 rear - front 计算出当前队列的有效数据个数，然后再通过 maxSize 取模操作
// 保证即使计算结果超出了maxSize，也能正确循环回数组大小内的有效范围，即绝对值
= rear - front
= ((rear - front) + maxSize) % maxSize
= (rear - front + maxSize) % maxSize
```

### ⑧、代码实现：环形队列

```java
package com.yuehai._01_sparseArrayAndQueue._02_queue;

import java.util.Scanner;

/**
 * 数组模拟循环队列
 * @author 月海
 * @date 2024/6/17 13:08
 * @description 数组模拟循环队列
 */
public class _02_CircleArrayQueue {
    
    /**
     * 队列头，指向当前队列的第一个元素的位置，初始值为 0
     */
    private int front = 0;
    
    /**
     * 队列尾，指向当前队列的最后一个元素的后一个位置，初始值为 0
     * rear 指向队列尾的后一个位置，即预留一个空间作为约定
     */
    private int rear = 0;
    
    /**
     * 队列的最大容量，实际容量为 maxSize - 1，预留一个空间作为约定
     */
    private final int maxSize;
    
    /**
     * 数组
     */
    private final int[] arr;
    
    /**
     * 构造方法
     * @param maxSize 队列的最大容量
     */
    public _02_CircleArrayQueue(int maxSize) {
        this.maxSize = maxSize;
        this.arr = new int[maxSize];
    }
    
    /**
     * 向队列中添加数据
     */
    public void addQueue(int n) {
        // 检查队列是否已满
        if ((rear + 1) % maxSize == front){
            throw new RuntimeException("队列已满，不能添加数据");
        }
        
        // 添加数据
        arr[rear] = n;
        System.out.println("添加数据：" + n + "，队列尾：" + rear);
        
        // 队列尾后移，取模操作，实现循环队列
        rear = (rear + 1) % maxSize;
    }
    
    /**
     * 从队列中取出数据
     */
    public void getQueue() {
        // 检查队列是否为空
        if (front == rear) {
            throw new RuntimeException("队列为空");
        }
        
        // 取出数据
        int returnDate = arr[front];
        System.out.println("取出数据：" + returnDate + "，队列头：" + front);
        
        // 取出数据后，将取出的数据置为 0
        arr[front] = 0;
        // 队列头后移，取模操作，实现循环队列
        front = (front + 1) % maxSize;
    }
    
    /**
     * 当前队列的有效数据个数
     * 先通过 rear - front 计算出当前队列的有效数据个数，然后再通过 maxSize 取模操作
     * 保证即使计算结果超出了maxSize，也能正确循环回数组大小内的有效范围，即绝对值
     * = rear - front
     * = ((rear - front) + maxSize) % maxSize
     * = (rear - front + maxSize) % maxSize
     */
    public int queueSize() {
        return (rear + maxSize - front) % maxSize;
    }
    
    public static void main(String[] args) {
        // 实例化对象
        _02_CircleArrayQueue queue = new _02_CircleArrayQueue(4);
        // 创建Scanner对象，用于接收键盘输入
        Scanner scanner = new Scanner(System.in);
        
        // 循环操作
        while (true){
            System.out.println("请选择操作：\n1 - 添加元素\n2 - 取出元素\n3 - 有效个数\n4 - 退出程序");
            // 读取输入的选项
            int choice = scanner.nextInt();
            
            // 根据输入的选项执行操作
            switch (choice) {
                case 1:
                    System.out.println("请输入要添加的元素：");
                    // 读取输入的元素
                    int num = scanner.nextInt();
                    try {
                        queue.addQueue(num);
                    } catch (RuntimeException e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case 2:
                    try {
                        queue.getQueue();
                    } catch (RuntimeException e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case 3:
                    int queueSize = queue.queueSize();
                    System.out.println("当前队列的有效数据个数为：" + queueSize);
                    break;
                case 4:
                    // 关闭 Scanner 对象
                    scanner.close();
                    // 结束程序
                    return;
                default:
                    System.out.println("无效输入，请重新选择！");
                    break;
            }
            
            System.out.println();
            // 输出当前队列
            System.out.print("当前队列为：");
            for (int i : queue.arr) {
                System.out.print(i + " ");
            }
            System.out.println();
            System.out.println("队列头：" + queue.front + "，队列尾：" + queue.rear);
            
            System.out.println("--------------------------");
        }
    }
    
}
```

# 三、链表

## 1、链表(Linked List)介绍

1. 链表是有序的列表，但是它在内存中是存储如下：
	1. 链表是以节点的方式来存储，是链式存储
	2. 每个节点包含 data 域， next 域：指向下一个节点
	3. 如图：链表的各个节点不一定是连续存储
	4. 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定

![|367](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240618091912.png)

2. 单链表(带头结点) 逻辑结构示意图如下

![](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240618093724.png)

## 2、主要作用和意义

> 链表是一种基础且灵活的数据结构，主要用于存储元素的集合或序列。
> 
> 它由一系列节点组成，每个节点包含数据部分和一个或多个指向列表中其他节点的链接（指针）。
> 
> 链表可以是单向的、双向的或者循环的。
> 
> 这种结构在计算机科学和软件开发中有广泛的应用，具有一系列的实际作用和意义

1. **动态数据结构**：链表是一个动态的数据结构，它可以在运行时动态地增加或删除节点，而不需要重新分配整个数据结构的存储空间。这使得链表在不确定数据量或频繁变化的数据集合管理中非常有用。
2. **高效的插入和删除操作**：相比于数组，链表在插入和删除节点时不需要移动其他元素。在数组中，这些操作通常需要O(n)的时间复杂度，而在链表中，如果已知目标位置的节点，插入和删除操作可以在O(1)的时间内完成。
3. **灵活的内存使用**：由于链表不需要在内存中连续存储，它们可以更灵活地分配内存，这对于内存使用受限或碎片化严重的系统尤其有用。
4. **实现多种高级数据结构**：链表是许多更复杂数据结构的基础，例如栈、队列、哈希表和图。例如，可以用链表来实现栈和队列的功能，使得这些数据结构的实现更加灵活和高效。
5. **方便的数据排序和管理**：链表结构使得数据的动态排序和管理变得容易。可以通过重新排列指针而不是数据本身来调整元素的顺序，这可以更高效地进行数据排序和处理。
6. **适用于大对象的存储**：对于存储大型数据对象的应用场景，链表减少了重新分配大块内存的需要。当对象很大且数量频繁变化时，使用链表可以避免大规模数据的复制和移动。
7. **支持复杂的算法**：链表特别适合支持一些复杂的算法，如多项式加法、大数运算等。在这些应用中，链表能动态调整数据的大小和顺序，提供算法实现所需的灵活性。
8. **循环链表和双向链表的特殊用途**：循环链表和双向链表扩展了链表的用途。循环链表适用于周期性任务的管理，双向链表则提供了从两个方向遍历数据的能力，适合于从尾部以及头部频繁修改数据的场景。
9. 总的来说，链表的主要优点在于其灵活性和低成本的插入删除操作，这使得它在需要频繁修改的数据集合管理中非常有用。虽然链表在某些操作（如随机访问）上不如数组高效，但在很多应用场景下，其优势使得它成为了解决问题的首选数据结构。
10. 单向链表和双向链表的比较分析：
	1. 单向链表查找的方向只能是一个方向，而双向链表可以向前或者向后查找。
	2. 单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除

## 3、单链表增删改查，包括顺序插入

> 使用带 head 头的单向链表实现：水浒英雄排行榜管理，完成对英雄人物的增删改查操作

### ①、添加方式一：直接添加到链表的尾部

1. 先创建一个 head 头节点，作用就是表示单链表的头
2. 后面我们每添加一个节点，就直接加入到链表的最后
3. 遍历：通过一个辅助变量遍历，帮助遍历整个链表

![|700](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240618102037.png)

### ②、添加方式二：**根据编号**将英雄插入到指定位置

> 根据排名将英雄插入到指定位置（如果有这个排名，则添加失败，并给出提示）

1. 需要按照编号的顺序添加
2. 首先找到新添加的节点的位置，通过辅助变量（指针），通过遍历来搞定
3. 新的节点 `next=temp.next`
4. 将 `temp.next=新的节点`

![|700](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240618102403.png)

### ③、修改节点功能

1. 先找到该节点，通过遍历
2. 找到后进行修改：

```java
temp.name = newHeroNode.name;

temp.nickname= newHeroNode.nickname
```

### ④、删除节点

1. 我们先找到需要删除的这个节点的前一个节点 temp
2. 将需要删除的节点的前一个节点的指针指向需要删除的节点的后一个节点

```java
temn.next=temp.next.next
```

3. 被删除的节点，将不会有其它引用指向，会被垃圾回收机制回收

### ⑤、代码实现单向链表

1. HeroNode 单向链表节点

```java
package com.yuehai._02_linkedList._01_singlyLinkedList;

/**
 * 定义 HeroNode ， 每个 HeroNode 对象就是一个节点
 */
public class HeroNode {
    
    /**
     * data 域：编号
     */
    public int no;
    
    /**
     * data 域：姓名
     */
    public String name;
    
    /**
     * data 域：昵称
     */
    public String nickname;
    
    /**
     * next 域：指向下一个节点
     */
    public HeroNode next;
    
    /**
     * 构造器
     *
     * @param no 编号
     * @param name 姓名
     * @param nickname 昵称
     */
    public HeroNode(int no, String name, String nickname) {
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }
    
    /**
     * 为了显示方便，重写 toString 方法
     * @return 节点信息
     * <p></p>
     * 重写 toString 方法时没有输出 next 域，因为 next 域指向下一个节点，如果输出 next 域，会导致同时输出后面的所有节点
     */
    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickname='" + nickname + '\'' +
                '}';
    }
}
```

2. 单链表代码实现

```java
package com.yuehai._02_linkedList._01_singlyLinkedList;

/**
 * 单向链表
 *
 * @author 月海
 * @date 2024/6/18 10:07
 * @description 单向链表
 */
public class SinglyLinkedList {
    
    /**
     * 头节点，不存放具体数据，作用是表示单链表的头，即第一个节点
     */
    HeroNode head = new HeroNode(0, "", "");
    
    /**
     * 添加方式一：直接添加到链表的尾部
     * @param heroNode 待添加的节点
     */
    public void add(HeroNode heroNode) {
        // 辅助变量，用于遍历链表；因为 head 节点不能动，所以需要一个辅助变量来表示当前节点，默认指向 head
        HeroNode temp = head;
        
        // 遍历链表，找到链表的最后；当 next 为 null 时，表示找到了链表的最后
        while (temp.next != null) {
            // 如果没有找到最后，将 temp 后移
            temp = temp.next;
        }
        
        // 当退出 while 循环时，temp 就指向了链表的最后；将最后这个节点的 next 指向新的节点
        temp.next = heroNode;
    }
    
    /**
     * 添加方式二：根据编号将英雄插入到指定位置
     * @param heroNode 待添加的节点
     */
    public void addByOrder(HeroNode heroNode) {
        // 辅助变量，用于遍历链表；因为 head 节点不能动，所以需要一个辅助变量来表示当前节点，默认指向 head
        HeroNode temp = head;
        // 标识添加的编号是否存在，默认为 false
        boolean flag = false;
        
        // 遍历链表，找到链表的最后；当 next 为 null 时，表示找到了链表的最后
        while (true) {
            // 如果 temp 已经是链表的最后一个节点，直接退出循环
            if (temp.next == null) {
                break;
            }
            /*
                不是最后一个节点，继续判断：
                如果当前节点的下一个节点的编号大于待添加的节点的编号，说明待添加的节点应该插入到当前节点的后面
                也就是当前节点的下一个节点的前面（但是因为这是单向链表，所以不能直接插入到当前节点的的下一个节点的前面，只能插入到当前节点的后面）
             */
            if (temp.next.no > heroNode.no) {
                // 说明位置找到，就在 temp 的后面插入，退出循环
                break;
            } else if (temp.next.no == heroNode.no) {
                // 说明希望添加的 heroNode 的编号已经存在
                flag = true;
                break;
            }
            
            // 本次循环没有找到，将 temp 后移，继续遍历
            temp = temp.next;
        }
        
        // 判断 flag 的值
        if (flag) {
            // 不能添加，说明编号已经存在
            System.out.println("准备插入的英雄的编号【" + heroNode.no + "】已经存在，不能加入");
        } else {
            /*
                可以插入
                将 heroNode 的下一个节点指向 temp 原先指向的下一个节点
                将 temp 的下一个节点指向 heroNode
                即：将 heroNode 插入到 temp 的后面，temp 的后面的节点插入到 heroNode 的后面
             */
            heroNode.next = temp.next;
            temp.next = heroNode;
        }
        
    }
    
    /**
     * 遍历输出链表
     */
    public void list() {
        // 判断链表是否为空；如果 head 的 next 为 null，表示没有指向的节点，即链表为空
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        
        // 辅助变量，用于遍历链表；因为 head 节点不能动，所以需要一个辅助变量来表示当前节点，默认指向 head
        HeroNode temp = head.next;
        
        // 如果 temp 为 null，表示遍历到了链表的最后
        while (temp != null) {
            // 输出节点的信息
            System.out.println(temp);
            // 将 temp 后移
            temp = temp.next;
        }
    }
    
    /**
     * 修改节点的信息，根据 no 编号来修改，即 no 编号不能改
     * @param newHeroNode 新的节点信息
     */
    public void update(HeroNode newHeroNode) {
        // 判断链表是否为空
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        
        // 辅助变量，用于遍历链表；因为 head 节点不能动，所以需要一个辅助变量来表示当前节点，默认指向 head
        HeroNode temp = head.next;
        // 标识是否找到该节点
        boolean flag = false;
        
        // 遍历链表
        while (temp != null) {
            // 找到了不为空的节点，判断是否为要修改的节点
            if (temp.no == newHeroNode.no) {
                // 找到了要修改的节点，退出循环
                flag = true;
                break;
            }
            // 没找到，将 temp 后移，继续遍历
            temp = temp.next;
        }
        
        // 根据 flag 判断是否找到要修改的节点
        if (flag) {
            // 找到了要修改的节点，修改节点的信息
            temp.name = newHeroNode.name;
            temp.nickname = newHeroNode.nickname;
        } else {
            // 没找到要修改的节点
            System.out.println("没有找到编号【" + newHeroNode.no + "】的节点，不能修改");
        }
        
    }
    
    /**
     * 删除节点
     * @param no 待删除节点的编号
     */
    public void delete(int no) {
        // 判断链表是否为空
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        
        // 辅助变量，用于遍历链表；因为 head 节点不能动，所以需要一个辅助变量来表示当前节点，默认指向 head
        HeroNode temp = head;
        // 标识是否找到该节点
        boolean flag = false;
        
        // 遍历链表
        while (temp.next != null) {
            // 找到了不为空的节点，判断是否为要删除的节点
            if (temp.next.no == no) {
                // 找到了要删除的节点，退出循环
                flag = true;
                break;
            }
            // 没找到，将 temp 后移，继续遍历
            temp = temp.next;
        }
        
        // 根据 flag 判断是否找到要删除的节点
        if (flag) {
            /*
                找到了要删除的节点，删除节点
                将 temp 的下一个节点指向 temp 的下下个节点
                即直接将 temp 的下一个节点指向 temp 的下下个节点，跳过 temp 的下一个节点，即删除了 temp 的下一个节点
                这样 temp 的下一个节点就没有引用指向它，它就会被垃圾回收机制回收
             */
            temp.next = temp.next.next;
        } else {
            // 没找到要删除的节点
            System.out.println("没有找到编号【" + no + "】的节点，不能删除");
        }
    }
    
    
    public static void main(String[] args) {
        // 先创建节点
        HeroNode hero1 = new HeroNode(1, "宋江", "及时雨");
        HeroNode hero2 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode hero3 = new HeroNode(3, "吴用", "智多星");
        HeroNode hero4 = new HeroNode(4, "林冲", "豹子头");
        
        // 创建一个单向链表
        SinglyLinkedList singlyLinkedList = new SinglyLinkedList();
        
        // 使用第一种添加方式
        // singlyLinkedList.add(hero1);
        // singlyLinkedList.add(hero2);
        // singlyLinkedList.add(hero3);
        // singlyLinkedList.add(hero4);
        
        // 使用第二种添加方式
        singlyLinkedList.addByOrder(hero1);
        singlyLinkedList.addByOrder(hero4);
        singlyLinkedList.addByOrder(hero3);
        singlyLinkedList.addByOrder(hero2);
        // 显示
        singlyLinkedList.list();
        
        // 修改
        HeroNode newHeroNode = new HeroNode(2, "小卢", "玉麒麟");
        singlyLinkedList.update(newHeroNode);
        // 显示
        System.out.println("修改后的链表：---------------------------");
        singlyLinkedList.list();
        
        // 删除
        singlyLinkedList.delete(3);
        // 显示
        System.out.println("删除后的链表：---------------------------");
        singlyLinkedList.list();
    }
    
}
```

2. 代码结果

```shell
HeroNode{no=1, name='宋江', nickname='及时雨'}
HeroNode{no=2, name='卢俊义', nickname='玉麒麟'}
HeroNode{no=3, name='吴用', nickname='智多星'}
HeroNode{no=4, name='林冲', nickname='豹子头'}
修改后的链表：---------------------------
HeroNode{no=1, name='宋江', nickname='及时雨'}
HeroNode{no=2, name='小卢', nickname='玉麒麟'}
HeroNode{no=3, name='吴用', nickname='智多星'}
HeroNode{no=4, name='林冲', nickname='豹子头'}
删除后的链表：---------------------------
HeroNode{no=1, name='宋江', nickname='及时雨'}
HeroNode{no=2, name='小卢', nickname='玉麒麟'}
HeroNode{no=4, name='林冲', nickname='豹子头'}

进程已结束，退出代码为 0
```

## 4、单链表测试题

- 单链表的常见面试题有如下：
1. 求单链表中有效节点的个数：遍历
2. 查找单链表中的倒数第 index 个结点 【新浪面试题】：两次遍历、<font color="#ff0000">（快慢指针）</font>
3. 单链表的反转【腾讯面试题，有点难度】：使用三个指针迭代
4. 从尾到头打印单链表 【百度】：Stack 栈
5. 合并两个有序的单链表，合并之后的链表依然有序

```java
package com.yuehai._02_linkedList._01_singlyLinkedList;

import java.util.Stack;

/**
 * 单向链表问题
 * @author 月海
 * @date 2024/6/21 15:40
 * @description 单向链表问题
 */
public class SinglyLinkedListQuestion {
    
    /**
     * 求单链表中有效节点的个数
     * @param head 头节点
     * @return 有效节点的个数
     */
    public int getLength(HeroNode head) {
        // 如果链表为空，返回 0
        if (head.next == null) {
            return 0;
        }
        
        // 用于记录有效节点的个数
        int length = 0;
        // 遍历链表，找到链表的最后；当 next 为 null 时，表示找到了链表的最后
        while (head.next != null) {
            // 将链表的有效节点个数加 1
            length++;
            // 将 head 后移
            head = head.next;
        }
        
        return length;
    }
    
    /**
     * 查找单链表中的倒数第 index 个节点
     * @param head 头节点
     * @param index 倒数第 index 个节点
     * @return 倒数第 index 个节点的信息
     */
    public HeroNode findLastIndexNode(HeroNode head, int index) {
        // 如果链表为空，返回 null
        if (head.next == null) {
            return null;
        }
        
        // 第一次遍历得到链表的长度（节点个数）
        int size = getLength(head);
        // 先做一个 index 的校验，如果 index 不在有效范围内，返回 null
        if (index <= 0 || index > size) {
            return null;
        }
        
        // 定义一个辅助变量，用于遍历链表，从 head 的下一个节点开始，即第一个有效节点
        HeroNode temp = head.next;
        // 第二次遍历 size - index 的位置，就是我们倒数的第 index 个节点
        for (int i = 0; i < size - index; i++) {
            temp = temp.next;
        }
        
        return temp;
    }
    
    /**
     * 查找单链表中的倒数第 index 个节点，使用快慢指针，只需要遍历一次
     * @param head 头节点
     * @param index 倒数第 index 个节点
     * @return 倒数第 index 个节点的信息
     */
    public HeroNode findLastIndexNode2(HeroNode head, int index) {
        // 如果链表为空，返回 null
        if (head.next == null) {
            return null;
        }
        
        // 先做一个 index 的校验，如果 index 不在有效范围内，返回 null
        if (index <= 0) {
            return null;
        }
        
        /*
            定义快慢指针，直接指向 head.next
            快指针先移动 index 步，然后快慢指针同时移动，直到快指针到达链表末尾
            注意：指针不需要从 head 开始，因为我们要找的是倒数第 index 个节点，所以直接指向 head.next
         */
        HeroNode fast = head.next;
        /*
            当快指针到达链表末尾时，慢指针就指向了倒数第 index 个节点
         */
        HeroNode slow = head.next;
        
        // 让 fast 先移动 index 步
        for (int i = 0; i < index; i++) {
            // 如果链表长度小于 index，直接返回 null
            if (fast == null) {
                return null;
            }
            fast = fast.next;
        }
        
        // 同时移动 fast 和 slow，直到 fast 到达链表末尾
        while (fast != null) {
            fast = fast.next;
            slow = slow.next;
        }
        
        // 此时 slow 指向倒数第 index 个节点
        return slow;
    }
    
    /**
     * 单链表的反转
     * @param head 头节点
     */
    public void reverseList(HeroNode head) {
        // 如果当前链表为空，或者只有一个节点，无需反转，直接返回
        if (head.next == null || head.next.next == null) {
            return;
        }
        
        // 定义一个新的链表，用于存放反转后的节点
        HeroNode reverseHead = new HeroNode(0, "", "");
        // 定义一个辅助变量，作为遍历原链表的指针，从头节点的下一个节点开始，即第一个有效节点
        HeroNode cur = head.next;
        // 用于临时存储 cur 的下一个节点，因为在改变 cur.next 指向时会丢失对下一个节点的引用
        HeroNode next;
        
        // 遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表 reverseHead 的最前端
        while (cur != null) {
            // 临时保存当前节点 cur 的下一个节点，以便在改变 cur.next 后能找到下一个节点继续遍历
            next = cur.next;
            
            /*
                将 cur 的下一个节点指向 reverseHead 的头节点之后
                即将 cur 节点的后面的节点删除，然后在 cur 节点的后面拼接上 reverseHead 的后面的节点
                实现将 cur 节点移动到新链表的头部
             */
            cur.next = reverseHead.next;
            /*
                将 reverseHead 的下一个节点指向当前处理的 cur 节点
                即将本次遍历的拼接完 reverseHead 所有有效节点的 cur 节点插入到 reverseHead 的第一个有效节点的前面
                完成将 cur 节点插入到新链表头部的操作
             */
            reverseHead.next = cur;
            
            // 将 cur 指针移动到原链表的下一个节点，继续遍历原链表
            cur = next;
        }
        
        // 将 head.next 指向 reverseHead.next，实现单链表的反转
        head.next = reverseHead.next;
    }
    
    /**
     * 从尾到头打印单链表，使用栈实现。
     * 注意：链表的结构不会直接影响栈的内存消耗。
     * 每个节点在栈中的显示格式看起来像嵌套结构，但实际上栈中存储的是节点的引用，
     * 而不是节点的实际内容。因此，打印链表时看到的嵌套结构只是一种展示格式，
     * 不会导致栈的内存使用量增大。
     * @param head 头节点
     */
    public void reversePrint(HeroNode head) {
        // 如果链表为空，直接返回
        if (head.next == null) {
            return;
        }
        
        // 创建一个栈，将各个节点压入栈中
        Stack<HeroNode> stack = new Stack<>();
        // 辅助变量，用于遍历链表
        HeroNode cur = head.next;
        
        // 将链表的所有节点压入栈中
        while (cur != null) {
            stack.push(cur);
            cur = cur.next;
        }
        
        // 将栈中的节点打印出来
        while (!stack.isEmpty()) {
            System.out.println(stack.pop());
        }
    }
    
    /**
     * 合并两个有序的单链表，合并之后的链表依然有序
     */
    public HeroNode mergeTwoLists(HeroNode head1, HeroNode head2) {
        // 如果 l1 为空，返回 l2
        if (head1 == null) {
            return head2;
        }
        // 如果 l2 为空，返回 l1
        if (head2 == null) {
            return head1;
        }
        
        // 定义一个新的链表，用于存放合并后的节点
        HeroNode mergeHead = new HeroNode(0, "", "");
        // 定义一个辅助变量，用于遍历合并后的链表
        HeroNode cur = mergeHead;
        
        // 比较两个链表的节点，将较小的节点依次加入到 mergeHead 链表中
        while (head1 != null && head2 != null) {
            // 判断 head1 和 head2 的编号大小
            if (head1.no < head2.no) {
                // 如果 head1 的编号小于 head2 的编号，将 head1 插入到 mergeHead 链表中
                cur.next = head1;
                head1 = head1.next;
            }else if (head1.no == head2.no) {
                // 如果 head1 和 head2 的编号相等，将 head1 和 head2 都插入到 mergeHead 链表中
                cur.next = head1;
                head1 = head1.next;
                head2 = head2.next;
            }else {
                // 如果 head1 的编号大于 head2 的编号，将 head2 插入到 mergeHead 链表中
                cur.next = head2;
                head2 = head2.next;
            }
            // 将 cur 指针后移
            cur = cur.next;
        }
        
        // 如果 head1 遍历完了，将 head2 剩余的节点插入到 mergeHead 链表中
        if (head1 == null) {
            cur.next = head2;
        }
        // 如果 head2 遍历完了，将 head1 剩余的节点插入到 mergeHead 链表中
        if (head2 == null) {
            cur.next = head1;
        }
        
        // 返回 mergeHead 链表，mergeHead 的第一个节点是空节点，所以返回 mergeHead.next
        return mergeHead.next;
    }
    
    public static void main(String[] args) {
        // 实例化
        SinglyLinkedListQuestion singlyLinkedListQuestion = new SinglyLinkedListQuestion();
        
        // 创建节点
        HeroNode hero1 = new HeroNode(1, "宋江", "及时雨");
        HeroNode hero2 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode hero3 = new HeroNode(3, "吴用", "智多星");
        HeroNode hero4 = new HeroNode(4, "林冲", "豹子头");
        
        // 创建链表
        SinglyLinkedList singlyLinkedList = new SinglyLinkedList();
        // 添加节点
        singlyLinkedList.add(hero1);
        singlyLinkedList.add(hero2);
        singlyLinkedList.add(hero3);
        singlyLinkedList.add(hero4);
        // 显示
        singlyLinkedList.list();
        System.out.println("--------------------");
        
        // 测试获取有效节点的个数
        System.out.println("有效节点的个数：" + singlyLinkedListQuestion.getLength(singlyLinkedList.head));
        System.out.println("--------------------");
        
        // 测试查找倒数第 index 个节点
        System.out.println("倒数第 2 个节点：" + singlyLinkedListQuestion.findLastIndexNode(singlyLinkedList.head, 2));
        // 测试查找倒数第 index 个节点，使用快慢指针
        System.out.println("倒数第 2 个节点：" + singlyLinkedListQuestion.findLastIndexNode2(singlyLinkedList.head, 2));
        System.out.println("--------------------");
        
        // 测试反转链表
        singlyLinkedListQuestion.reverseList(singlyLinkedList.head);
        // 显示
        singlyLinkedList.list();
        System.out.println("--------------------");
        
        // 测试从尾到头打印链表
        singlyLinkedListQuestion.reversePrint(singlyLinkedList.head);
        System.out.println("--------------------");
        System.out.println("--------------------");
        
        // 创建第二个链表
        SinglyLinkedList singlyLinkedList2 = new SinglyLinkedList();
        HeroNode hero5 = new HeroNode(1, "宋江", "及时雨");
        HeroNode hero6 = new HeroNode(3, "吴用", "智多星");
        HeroNode hero7 = new HeroNode(5, "关胜", "大刀");
        singlyLinkedList2.add(hero5);
        singlyLinkedList2.add(hero6);
        singlyLinkedList2.add(hero7);
        singlyLinkedList2.list();
        System.out.println("--------------------");
        // 创建第三个链表
        SinglyLinkedList singlyLinkedList3 = new SinglyLinkedList();
        HeroNode hero8 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode hero9 = new HeroNode(3, "吴用", "智多星");
        HeroNode hero10 = new HeroNode(4, "林冲", "豹子头");
        HeroNode hero11 = new HeroNode(6, "秦明", "霹雳火");
        singlyLinkedList3.add(hero8);
        singlyLinkedList3.add(hero9);
        singlyLinkedList3.add(hero10);
        singlyLinkedList3.add(hero11);
        singlyLinkedList3.list();
        System.out.println("--------------------");
        
        // 测试合并两个有序链表
        HeroNode mergeTwoLists = singlyLinkedListQuestion.mergeTwoLists(singlyLinkedList2.head, singlyLinkedList3.head);
        // 遍历合并后的链表
        HeroNode temp = mergeTwoLists.next;
        while (temp != null) {
            System.out.println(temp);
            temp = temp.next;
        }
        
    }
    
}
```

## 5、双向链表

![[attachments/Pasted image 20240625164347.png]]

- 对上图的说明：
1. 遍历：和单链表一样，只是可以向前，也可以向后查找
2. 添加：添加到双向链表的最后

```java
// 先找到双向链表的最后这个节点
// 将新节点的 next 指向 tail
heroNode.next = tail;
// 将新节点的 pre 指向 tail 的 pre
heroNode.pre = tail.pre;

// 将 tail 的 pre 的 next 指向新节点
tail.pre.next = heroNode;
// 将 tail 的 pre 指向新节点
tail.pre = heroNode;
```

3. 修改：思路和单向链表一样
4. 删除：因为是双向链表，因此，我们可以实现自我删除某个节点

```java
// 1、直接找到要删除的这个节点，比如 temp
// 2、将要删除的节点的前一个节点的下一个节点、指向下下个节点
temp.pre.next = temp.next
// 3、将要删除的节点的下一个节点的前一个节点、指向上上个节点
temp.next.pre = temp.pre;
```

5. HeroNode2 双向链表节点

```java
package com.yuehai._02_linkedList._02_doublyLinkedList;

/**
 * 定义 HeroNode ， 每个 HeroNode 对象就是一个节点
 * 双向链表的节点
 */
public class HeroNode2 {
    
    /**
     * data 域：编号
     */
    public int no;
    
    /**
     * data 域：姓名
     */
    public String name;
    
    /**
     * data 域：昵称
     */
    public String nickname;
    
    /**
     * next 域：指向下一个节点
     */
    public HeroNode2 next;
    
    /**
     * pre 域：指向前一个节点
     */
    public HeroNode2 pre;
    
    /**
     * 构造器
     *
     * @param no 编号
     * @param name 姓名
     * @param nickname 昵称
     */
    public HeroNode2(int no, String name, String nickname) {
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }
    
    /**
     * 为了显示方便，重写 toString 方法
     * @return 节点信息
     * <p></p>
     * 重写 toString 方法时没有输出 next 域，因为 next 域指向下一个节点，如果输出 next 域，会导致同时输出后面的所有节点
     */
    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickname='" + nickname + '\'' +
                '}';
    }
}
```

6. 实例代码

```java
package com.yuehai._02_linkedList._02_doublyLinkedList;


/**
 * 双向链表
 * @author 月海
 * @date 2024/6/26 10:04
 * @description 双向链表
 */
public class DoublyLinkedList {
    
    /**
     * 头节点，不存放具体数据，作用是表示单链表的头，即第一个节点
     */
    HeroNode2 head = new HeroNode2(0, "", "");
    /**
     * 尾节点，不存放具体数据，作用是表示单链表的尾，即最后一个节点
     */
    HeroNode2 tail = new HeroNode2(0, "", "");
    
    /**
     * 构造器
     */
    public DoublyLinkedList() {
        // 初始化时，将头节点的 next 指向尾节点，将尾节点的 pre 指向头节点
        head.next = tail;
        tail.pre = head;
    }
    
    /**
     * 遍历输出链表
     */
    public void list() {
        // 判断链表是否为空；如果 head 的 next 的 next 为 null，表示头节点和尾节点之间没有节点，即链表为空
        if (head.next.next == null) {
            System.out.println("链表为空");
            return;
        }
        
        // 辅助变量，用于遍历链表；因为 head 节点不能动，所以需要一个辅助变量来表示当前节点，默认指向 head
        HeroNode2 temp = head.next;
        
        // 如果 temp 的 next 为 null，表示遍历到了链表的最后，即 temp 为 tail
        while (temp.next != null) {
            // 输出节点的信息
            System.out.println(temp);
            // 将 temp 后移
            temp = temp.next;
        }
    }
    
    /**
     * 反向遍历输出链表
     */
    public void reverseList() {
        // 判断链表是否为空；如果 tail 的 pre 的 pre 为 null，表示头节点和尾节点之间没有节点，即链表为空
        if (tail.pre.pre == null) {
            System.out.println("链表为空");
            return;
        }
        
        // 辅助变量，用于遍历链表；因为 tail 节点不能动，所以需要一个辅助变量来表示当前节点，默认指向 tail
        HeroNode2 temp = tail.pre;
        
        // 如果 temp 的 pre 为 null，表示遍历到了链表的最前，即 temp 为 head
        while (temp.pre != null) {
            // 输出节点的信息
            System.out.println(temp);
            // 将 temp 前移
            temp = temp.pre;
        }
    }
    
    /**
     * 添加方式一：直接添加到链表的尾部
     * @param heroNode 待添加的节点
     */
    public void add(HeroNode2 heroNode) {
        // 将新节点的 next 指向 tail
        heroNode.next = tail;
        // 将新节点的 pre 指向 tail 的 pre
        heroNode.pre = tail.pre;
        
        // 将 tail 的 pre 的 next 指向新节点
        tail.pre.next = heroNode;
        // 将 tail 的 pre 指向新节点
        tail.pre = heroNode;
    }
    
    /**
     * 添加方式二：添加到链表的头部
     * @param heroNode 待添加的节点
     */
    public void addAtHead(HeroNode2 heroNode) {
        // 将新节点的 next 指向 head 的下一个节点
        heroNode.next = head.next;
        // 将新节点的 pre 指向 head
        heroNode.pre = head;
        
        // 将 head 的下一个节点的 pre 指向新节点
        head.next.pre = heroNode;
        // 将 head 的 next 指向新节点
        head.next = heroNode;
    }
    
    /**
     * 添加方式三：根据编号将英雄插入到指定位置
     * @param heroNode 待添加的节点
     */
    public void addByOrder(HeroNode2 heroNode) {
        // 辅助变量，用于遍历链表；因为 head 节点不能动，所以需要一个辅助变量来表示当前节点，默认指向 head 的下一个节点
        HeroNode2 temp = head.next;
        // 标识添加的编号是否存在，默认为 false，表示不存在
        boolean flag = false;
        
        // 遍历链表，找到链表的最后；当 next 为 null 时，表示找到了链表的最后
        while (temp.next != null) {
            /*
                不是最后一个节点，继续判断：
                如果当前节点的下一个节点的编号大于待添加的节点的编号，说明待添加的节点应该插入到当前节点的后面
                也就是当前节点的下一个节点的前面（但是因为这是单向链表，所以不能直接插入到当前节点的的下一个节点的前面，只能插入到当前节点的后面）
             */
            if (temp.no > heroNode.no) {
                // 说明位置找到，就在 temp 的后面插入，退出循环
                break;
            } else if (temp.no == heroNode.no) {
                // 说明希望添加的 heroNode 的编号已经存在
                flag = true;
                break;
            }
            
            // 本次循环没有找到，将 temp 后移，继续遍历
            temp = temp.next;
        }
        
        // 判断 flag 的值
        if (flag) {
            // 不能添加，说明编号已经存在
            System.out.println("准备插入的英雄的编号【" + heroNode.no + "】已经存在，不能加入");
        } else {
            // 可以插入，将新节点的 next 指向 temp
            heroNode.next = temp;
            // 将新节点的 pre 指向 temp 的 pre
            heroNode.pre = temp.pre;
            
            // 将 temp 的 pre 的 next 指向新节点
            temp.pre.next = heroNode;
            // 将 temp 的 pre 指向新节点
            temp.pre = heroNode;
        }
    }
    
    /**
     * 修改节点的信息，根据编号来修改，即编号不能改
     */
    public void update(HeroNode2 newHeroNode) {
        // 判断链表是否为空；如果 head 的 next 的 next 为 null，表示头节点和尾节点之间没有节点，即链表为空
        if (head.next.next == null) {
            System.out.println("链表为空");
            return;
        }
        
        // 辅助变量，用于遍历链表；因为 head 节点不能动，所以需要一个辅助变量来表示当前节点，默认指向 head 的下一个节点
        HeroNode2 temp = head.next;
        // 标识是否找到待修改的节点，默认为 false
        boolean flag = false;
        
        // 遍历链表，找到待修改的节点；当 next 为 null 时，表示找到了链表的最后
        while (temp.next != null) {
            // 如果 temp 的 no 等于 newHeroNode 的 no，表示找到了待修改的节点
            if (temp.no == newHeroNode.no) {
                // 找到了待修改的节点，修改节点的信息
                temp.name = newHeroNode.name;
                temp.nickname = newHeroNode.nickname;
                // 修改成功，将 flag 置为 true
                flag = true;
                break;
            }
            // 将 temp 后移
            temp = temp.next;
        }
        
        // 根据 flag 的值判断是否找到待修改的节点
        if (flag) {
            System.out.println("修改成功");
        } else {
            System.out.println("未找到编号【" + newHeroNode.no + "】的节点，修改失败");
        }
    }
    
    /**
     * 删除节点
     */
    public void delete(int no) {
        // 判断链表是否为空；如果 head 的 next 的 next 为 null，表示头节点和尾节点之间没有节点，即链表为空
        if (head.next.next == null) {
            System.out.println("链表为空");
            return;
        }
        
        // 辅助变量，用于遍历链表；因为 head 节点不能动，所以需要一个辅助变量来表示当前节点，默认指向 head
        HeroNode2 temp = head.next;
        // 标识是否找到待删除的节点，默认为 false
        boolean flag = false;
        
        // 遍历链表，找到待删除的节点；当 next 为 null 时，表示找到了链表的最后
        while (temp.next != null) {
            // 如果 temp 的 no 等于待删除的 no，表示找到了待删除的节点
            if (temp.no == no) {
                // 找到了待删除的节点，将 flag 置为 true，退出循环
                flag = true;
                break;
            }
            // 将 temp 后移
            temp = temp.next;
        }
        
        // 根据 flag 的值判断是否找到待删除的节点
        if (flag) {
            // 找到了待删除的节点，将待删除的节点从链表中删除
            temp.pre.next = temp.next;
            temp.next.pre = temp.pre;
        } else {
            System.out.println("未找到编号【" + no + "】的节点，删除失败");
        }
    }
    
    public static void main(String[] args) {
        // 创建节点
        HeroNode2 hero1 = new HeroNode2(1, "宋江", "及时雨");
        HeroNode2 hero2 = new HeroNode2(2, "卢俊义", "玉麒麟");
        HeroNode2 hero3 = new HeroNode2(3, "吴用", "智多星");
        HeroNode2 hero4 = new HeroNode2(4, "林冲", "豹子头");
        
        // 创建链表
        DoublyLinkedList doublyLinkedList = new DoublyLinkedList();
        // 添加节点
        doublyLinkedList.add(hero1);
        doublyLinkedList.add(hero2);
        doublyLinkedList.add(hero3);
        doublyLinkedList.add(hero4);
        // 遍历输出链表
        doublyLinkedList.list();
        System.out.println("--------------------");
        // 反向遍历输出链表
        doublyLinkedList.reverseList();
        System.out.println("--------------------");
        
        // 创建节点
        HeroNode2 hero5 = new HeroNode2(5, "鲁智深", "花和尚");
        HeroNode2 hero6 = new HeroNode2(6, "武松", "行者");
        HeroNode2 hero7 = new HeroNode2(7, "韩滔", "豹子头");
        // 将节点添加到链表的头部
        doublyLinkedList.addAtHead(hero5);
        doublyLinkedList.addAtHead(hero6);
        doublyLinkedList.addAtHead(hero7);
        // 遍历输出链表
        doublyLinkedList.list();
        System.out.println("--------------------");
        
        // 创建节点
        HeroNode2 hero8 = new HeroNode2(8, "李逵", "黑旋风");
        HeroNode2 hero9 = new HeroNode2(9, "花荣", "小李广");
        HeroNode2 hero10 = new HeroNode2(10, "柴进", "小旋风");
        // 根据编号将英雄插入到指定位置
        doublyLinkedList.addByOrder(hero8);
        doublyLinkedList.addByOrder(hero9);
        doublyLinkedList.addByOrder(hero10);
        // 遍历输出链表
        doublyLinkedList.list();
        System.out.println("--------------------");
        
        // 修改节点
        HeroNode2 newHeroNode = new HeroNode2(2, "小卢", "玉麒麟");
        doublyLinkedList.update(newHeroNode);
        // 遍历输出链表
        doublyLinkedList.list();
        System.out.println("--------------------");
        
        // 删除节点
        doublyLinkedList.delete(3);
        // 遍历输出链表
        doublyLinkedList.list();
        
    }
}
```

## 6、单向环形链表

### ①、Joseph 约瑟夫问题

1. 设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为k（1<=k<=n）的人从 1 开始报数，数到 m 的那个人出列，它的下一位又从1开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。
2. 提示：用一个不带头结点的循环链表来处理Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直到最后一个结点从链表中删除算法结束。

![](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240628123412.png)

3. 创建环形链表的思路图解：
	1. 构建一个单向的环形链表思路：
		1. 先创建第一个节点 first 为空，当添加第一个节点时赋值给 first，并将 `first.next` 指向自己，形成环形
		2. 后面当我们每创建一个新的节点，就把该节点，加入到已有的环形链表中即可
	2. 遍历环形链表：
		1. 先让一个辅助指针（变量）curBoy，指向 first 节点
		2. 然后通过一个 while 循环遍历该环形链表即可 `curBoy.next=first` 结束 

![](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240628125116.png)

4. 小孩出圈的思路分析图，（设 n=5，即有 5 个人；k=1，即从第 1 个人开始报数；m=2，即数 2 下）：
	1. 创建一个辅助指针（变量）helper（preHeroNode），事先应该指向环形链表的最后这个节点
	2. 小孩报数前，先让 first 和 helper 移动 k-1 次
	3. 当小孩报数时，让 first 和 helper 指针同时的移动 m-1 次，这时就可以将 first 指向的小孩节点出圈
		1. `first = first.next`
		2. `helper.next = first`
	4. 原来 first 指向的节点就没有任何引用，就会被回收
	5. 出圈的顺序：`2->4->1->5->3` 

![](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240628125131.png)

### ②、实例代码

1. HeroNode3 单项环形链表节点

```java
package com.yuehai._02_linkedList._03_singlyCircularLinkedList;

/**
 * 定义 HeroNode ， 每个 HeroNode 对象就是一个节点
 * 单项环形链表
 */
public class HeroNode3 {
    
    /**
     * data 域：编号
     */
    public int no;
    
    /**
     * data 域：姓名
     */
    public String name;
    
    /**
     * data 域：昵称
     */
    public String nickname;
    
    /**
     * next 域：指向下一个节点
     */
    public HeroNode3 next;
    
    /**
     * 构造器
     *
     * @param no 编号
     * @param name 姓名
     * @param nickname 昵称
     */
    public HeroNode3(int no, String name, String nickname) {
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }
    
    /**
     * 为了显示方便，重写 toString 方法
     * @return 节点信息
     * <p></p>
     * 重写 toString 方法时没有输出 next 域，因为 next 域指向下一个节点，如果输出 next 域，会导致同时输出后面的所有节点
     */
    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickname='" + nickname + '\'' +
                '}';
    }
}
```

2. 实例代码

```java
package com.yuehai._02_linkedList._03_singlyCircularLinkedList;

/**
 * 单向循环链表
 * @author 月海
 * @date 2024/6/28 12:40
 * @description 单向循环链表
 */
public class SinglyCircularLinkedList {
    
    /**
     * 第一个节点
     */
    private HeroNode3 first;
    
    /**
     * 添加节点到单向循环链表
     */
    public void add(HeroNode3 heroNode) {
        // 如果是第一个节点
        if (first == null) {
            first = heroNode;
            first.next = first;
            return;
        }
        
        // 定义一个辅助指针，默认指向第一个节点
        HeroNode3 curHeroNode = first;
        // 遍历链表，找到最后一个节点
        while (curHeroNode.next != first) {
            // 后移
            curHeroNode = curHeroNode.next;
        }
        
        // 将最后一个节点的 next 指向新的节点
        curHeroNode.next = heroNode;
        // 新的节点的 next 指向第一个节点
        heroNode.next = first;
    }
    
    /**
     * 遍历单向循环链表
     */
    public void list() {
        // 如果链表为空
        if (first == null) {
            System.out.println("链表为空");
            return;
        }
        
        // 定义一个辅助指针，默认指向第一个节点
        HeroNode3 curHeroNode = first;
        // 遍历链表
        do {
            // 输出节点信息
            System.out.println(curHeroNode);
            // 后移
            curHeroNode = curHeroNode.next;
            // 如果是第一个节点，说明遍历完毕
        } while (curHeroNode != first);
    }
    
    /**
     * 根据编号修改节点
     */
    public void update(HeroNode3 newHeroNode) {
        // 如果链表为空
        if (first == null) {
            System.out.println("链表为空");
            return;
        }
        
        // 定义一个辅助指针，默认指向第一个节点
        HeroNode3 curHeroNode = first;
        // 标记是否找到该节点
        boolean flag = false;
        // 遍历链表
        do {
            // 找到该节点
            if (curHeroNode.no == newHeroNode.no) {
                flag = true;
                break;
            }
            // 后移
            curHeroNode = curHeroNode.next;
            // 如果是第一个节点，说明遍历完毕
        } while (curHeroNode != first);
        
        // 如果找到该节点
        if (flag) {
            curHeroNode.name = newHeroNode.name;
            curHeroNode.nickname = newHeroNode.nickname;
        } else {
            System.out.println("没有找到编号为 " + newHeroNode.no + " 的节点");
        }
    }
    
    /**
     * 根据编号删除节点
     */
    public void delete(int no) {
        // 如果链表为空
        if (first == null) {
            System.out.println("链表为空");
            return;
        }
        
        // 定义一个辅助指针，表示当前节点的前一个节点
        HeroNode3 preHeroNode = null;
        // 定义一个辅助指针，表示当前节点，默认指向第一个节点
        HeroNode3 curHeroNode = first;
        // 标记是否找到该节点
        boolean flag = false;
        
        // 遍历链表
        do {
            // 找到该节点
            if (curHeroNode.no == no) {
                flag = true;
                break;
            }
            // 将前一个节点后移
            preHeroNode = curHeroNode;
            // 将当前节点后移
            curHeroNode = curHeroNode.next;
            // 如果是第一个节点，说明遍历完毕
        } while (curHeroNode != first);
        
        // 如果没有找到该节点
        if (!flag) {
            System.out.println("没有找到编号为 " + no + " 的节点");
            return;
        }
        
        // 如果 curHeroNode == first && curHeroNode.next == first，表示链表只有一个节点
        if (curHeroNode == first && curHeroNode.next == first) {
            System.out.println("当前删除的节点是：" + first);
            
            // 如果只有一个节点，将 first 置空
            first = null;
        }else if(curHeroNode == first){
            System.out.println("当前删除的节点是：" + curHeroNode);
            
            // 如果链表有多个节点，且删除的是第一个节点，将最后一个节点的 next 指向第一个节点的 next，即删除第一个节点
            while (curHeroNode.next != first) {
                // 将当前节点后移，直到当前节点的 next 指向第一个节点，即遍历完毕
                curHeroNode = curHeroNode.next;
            }
            // 将最后一个节点的 next 指向第一个节点的 next
            curHeroNode.next = first.next;
            // 将 first 指向第一个节点的 next
            first = first.next;
        }else {
            System.out.println("当前删除的节点是：" + curHeroNode);
            
            // 如果有多个节点，且删除的不是第一个节点，将前一个节点的 next 指向当前节点的 next
            preHeroNode.next = curHeroNode.next;
        }
    }
    
    /**
     * Joseph 约瑟夫问题
     * @param startNo 从第几个节点开始数，问题中的 k
     * @param countNum 数几下，问题中的 m
     * <p></p>
     * 约瑟夫问题是一个著名的问题：
     * 设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1<=k<=n）的人从 1 开始报数，
     * 数到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。
     */
    public void joseph(int startNo, int countNum) {
        // 如果链表为空
        if (first == null) {
            System.out.println("链表为空，问题结束");
            return;
        }
        if (startNo < 1) {
            System.out.println("参数输入有误，请重新输入");
            return;
        }
        
        // 定义一个辅助指针，表示当前节点的前一个节点
        HeroNode3 preHeroNode = first;
        // 遍历链表，将 preHeroNode 移动到链表的最后一个节点
        while (preHeroNode.next != first) {
            preHeroNode = preHeroNode.next;
        }
        
        // 定义一个辅助指针，表示当前节点，默认指向第一个节点
        HeroNode3 curHeroNode = first;
        
        // 从第几个节点开始数，问题中的 k；如果 startNo == 1，表示从第一个节点开始数，不需要移动
        for (int i = 1; i < startNo; i++) {
            preHeroNode = curHeroNode;
            curHeroNode = curHeroNode.next;
        }
        
        // 循环删除节点，直到只剩下一个节点
        while (preHeroNode != curHeroNode) {
            // k 移动完毕后，开始报数，问题中的 m；如果 countNum == 1，表示数一个数，不需要移动
            for (int i = 1; i < countNum; i++) {
                preHeroNode = curHeroNode;
                curHeroNode = curHeroNode.next;
            }
            
            // 出圈
            System.out.println("出圈的节点是：" + curHeroNode);
            // 删除当前节点
            preHeroNode.next = curHeroNode.next;
            // 移动当前节点指针
            curHeroNode = curHeroNode.next;
        }
        
        // 最后一个节点出圈
        System.out.println("最后出圈的节点是：" + curHeroNode);
        // 清空链表
        first = null;
    }
    
    public static void main(String[] args) {
        // 创建节点
        HeroNode3 heroNode1 = new HeroNode3(1, "宋江", "及时雨");
        HeroNode3 heroNode2 = new HeroNode3(2, "卢俊义", "玉麒麟");
        HeroNode3 heroNode3 = new HeroNode3(3, "吴用", "智多星");
        HeroNode3 heroNode4 = new HeroNode3(4, "林冲", "豹子头");
        HeroNode3 heroNode5 = new HeroNode3(5, "鲁智深", "花和尚");
        HeroNode3 heroNode6 = new HeroNode3(6, "李逵", "黑旋风");
        
        // 创建单向循环链表
        SinglyCircularLinkedList singlyCircularLinkedList = new SinglyCircularLinkedList();
        // 添加节点
        singlyCircularLinkedList.add(heroNode1);
        singlyCircularLinkedList.add(heroNode2);
        singlyCircularLinkedList.add(heroNode3);
        singlyCircularLinkedList.add(heroNode4);
        singlyCircularLinkedList.add(heroNode5);
        singlyCircularLinkedList.add(heroNode6);
        // 遍历单向循环链表
        System.out.println("---- 遍历单向循环链表 ----------------");
        singlyCircularLinkedList.list();
        
        // 修改节点
        HeroNode3 newHeroNode = new HeroNode3(2, "小卢", "玉麒麟");
        singlyCircularLinkedList.update(newHeroNode);
        System.out.println("---- 修改节点 ----------------");
        singlyCircularLinkedList.list();
        
        // 删除节点
        System.out.println("---- 删除节点 ----------------");
        singlyCircularLinkedList.delete(6);
        System.out.println("---- 遍历单向循环链表 ----------------");
        singlyCircularLinkedList.list();
        
        // Joseph 约瑟夫问题
        System.out.println("---- Joseph 约瑟夫问题 ----------------");
        singlyCircularLinkedList.joseph(1, 2);
    }
    
}
```

3. 结果：

```shell
---- 遍历单向循环链表 ----------------
HeroNode{no=1, name='宋江', nickname='及时雨'}
HeroNode{no=2, name='卢俊义', nickname='玉麒麟'}
HeroNode{no=3, name='吴用', nickname='智多星'}
HeroNode{no=4, name='林冲', nickname='豹子头'}
HeroNode{no=5, name='鲁智深', nickname='花和尚'}
HeroNode{no=6, name='李逵', nickname='黑旋风'}
---- 修改节点 ----------------
HeroNode{no=1, name='宋江', nickname='及时雨'}
HeroNode{no=2, name='小卢', nickname='玉麒麟'}
HeroNode{no=3, name='吴用', nickname='智多星'}
HeroNode{no=4, name='林冲', nickname='豹子头'}
HeroNode{no=5, name='鲁智深', nickname='花和尚'}
HeroNode{no=6, name='李逵', nickname='黑旋风'}
---- 删除节点 ----------------
当前删除的节点是：HeroNode{no=6, name='李逵', nickname='黑旋风'}
---- 遍历单向循环链表 ----------------
HeroNode{no=1, name='宋江', nickname='及时雨'}
HeroNode{no=2, name='小卢', nickname='玉麒麟'}
HeroNode{no=3, name='吴用', nickname='智多星'}
HeroNode{no=4, name='林冲', nickname='豹子头'}
HeroNode{no=5, name='鲁智深', nickname='花和尚'}
---- Joseph 约瑟夫问题 ----------------
出圈的节点是：HeroNode{no=2, name='小卢', nickname='玉麒麟'}
出圈的节点是：HeroNode{no=4, name='林冲', nickname='豹子头'}
出圈的节点是：HeroNode{no=1, name='宋江', nickname='及时雨'}
出圈的节点是：HeroNode{no=5, name='鲁智深', nickname='花和尚'}
最后出圈的节点是：HeroNode{no=3, name='吴用', nickname='智多星'}

进程已结束，退出代码为 0
```

# 四、栈

## 1、栈的一个实际需求

1. 请输入一个表达式：`7 * 2 * 2 - 5 + 1 - 5 + 3 - 3`，点击计算

![|321](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240701091152.png)

2. 请问：计算机底层是如何运算得到结果的？注意不是简单的把算式列出运算
3. 因为我们看这个算式：`7 * 2 * 2 - 5`，但是计算机怎么理解这个算式的(对计算机而言，它接收到的就是一个字符串)
4. 我们讨论的是这个问题 -> <font color="#ff0000">栈</font>

## 2、栈的介绍

1. 栈的英文为：`stack`
2. 栈是一个<font color="#ff0000">先入后出</font>(FILO-First In Last Out)的有序列表。
3. 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。
4. 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除
5. 图解方式说明出栈(pop)和入栈(push)的概念

![|637](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240701091401.png)

![|625](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240701091406.png)

## 3、栈的应用场景

1. 子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。
2. 处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。
3. 表达式的转 `中缀表达式转后缀表达式` 与求值(实际解决)。
4. 二叉树的遍历。
5. 图形的深度优先(depth 一 first)搜索法。

## 4、栈的快速入门

1. 用数组模拟栈的使用，由于栈是一种有序列表，当然可以使用数组的结构来储存栈的数据内容，下面我们就用数组模拟栈的出栈，入栈等操作。
2. 实现思路分析，并画出示意图

```java
// 定义一个 top 来表示栈顶，初始化为 -1

// 入栈的操作，当有数据加入到栈时：
top++;
stack[top]=data;

// 出栈的操作：
intvalue=stack[top];
top--;
return value;
```

![|500](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240701094242.png)

3. 实例代码：使用数组实现栈

```java
package com.yuehai._04_stack;

/**
 * 使用数组模拟栈
 * @author 月海
 * @date 2024/7/1 10:00
 * @description 使用数组模拟栈
 */
public class ArrayStack {
    /**
     * 栈的最大容量
     */
    private final int maxSize;
    
    /**
     * 数组模拟栈，数据放在该数组中
     */
    private final String[] stack;
    
    /**
     * 栈顶，初始化为 -1
     */
    private int top = -1;
    
    /**
     * 构造器
     * @param maxSize 栈的最大容量
     */
    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new String[this.maxSize];
    }
    
    /**
     * 栈满
     * @return 是否栈满
     */
    public boolean isFull() {
        return top == maxSize - 1;
    }
    
    /**
     * 栈空
     * @return 是否栈空
     */
    public boolean isEmpty() {
        return top == -1;
    }
    
    /**
     * 入栈
     * @param value 入栈的值
     */
    public void push(String value) {
        // 判断栈是否满
        if (isFull()) {
            System.out.println("栈满");
            return;
        }
        
        // 栈顶后移
        top++;
        // 入栈
        stack[top] = value;
    }
    
    /**
     * 出栈
     * @return 出栈的值
     */
    public String pop() {
        // 判断栈是否空
        if (isEmpty()) {
            throw new RuntimeException("栈空");
        }
        
        // 出栈
        String value = stack[top];
        // 栈顶前移
        top--;
        
        return value;
    }
    
    /**
     * 遍历栈
     */
    public void list() {
        // 判断栈是否空
        if (isEmpty()) {
            System.out.println("栈空");
            return;
        }
        
        // 从栈顶开始遍历
        for (int i = top; i >= 0; i--) {
            System.out.println("栈中指针为 " + i + " 的值为：" + stack[i]);
        }
    }
    
    /**
     * 获取栈顶的值，不出栈
     * @return 栈顶的值
     */
    public String peek() {
        return stack[top];
    }
}
```

4. 实例代码：demo 测试

```java
package com.yuehai._04_stack;

/**
 * 使用数组模拟栈测试类
 * @author 月海
 * @date 2024/7/1 10:17
 * @description 使用数组模拟栈测试类
 */
public class ArrayStackDemo {
    public static void main(String[] args) {
        // 创建一个 ArrayStack 对象
        ArrayStack stack = new ArrayStack(4);
        // 入栈
        stack.push("1");
        stack.push("2");
        stack.push("3");
        stack.push("4");
        // 遍历栈
        stack.list();
        
        // 出栈
        System.out.println("本次出栈的数据是：" + stack.pop());
        System.out.println("本次出栈的数据是：" + stack.pop());
        System.out.println("本次出栈的数据是：" + stack.pop());
        System.out.println("本次出栈的数据是：" + stack.pop());
        // 再次出栈
        stack.pop();
    }
}
```

5. 结果：

```shell
栈中指针为 3 的值为：4
栈中指针为 2 的值为：3
栈中指针为 1 的值为：2
栈中指针为 0 的值为：1
本次出栈的数据是：4
本次出栈的数据是：3
本次出栈的数据是：2
本次出栈的数据是：1
Exception in thread "main" java.lang.RuntimeException: 栈空
	at com.yuehai._04_stack.ArrayStack.pop(ArrayStack.java:74)
	at com.yuehai._04_stack.ArrayStackDemo.main(ArrayStackDemo.java:27)

进程已结束，退出代码为 1
```

## 5、中缀、前缀、后缀表达式分类

1. 中缀表达式（Infix expression）是一种常见的算术或逻辑公式表示方式，其中运算符位于相关的操作数之间。这种表示法直接反映了我们通常书写和理解算术表达式的方式。例如，在表达式 3 + 4 中，加号（+）是一个运算符，它位于两个操作数 3 和 4 的中间。
2. 中缀表达式特点：
	1. 直观： 中缀表达式对人类来说非常直观易懂，因为它符合我们日常书写和理解数学运算的习惯。
	2. 需要括号： 为了明确操作的优先级，中缀表达式常常需要使用括号。例如，表达式 `3 + 4 * 2` 和 `(3 + 4) * 2` 表示的计算结果是不同的。
	3. 运算符优先级： 在不使用括号的情况下，中缀表达式依赖于预定义的运算符优先级和结合性规则来解释。例如，乘法运算符 `*` 通常具有比加法运算符 `+` 更高的优先级。
3. 除了中缀表达式之外，还有**前缀表达式**（Prefix expression，或称波兰表示法）和**后缀表达式**（Postfix expression，或称逆波兰表示法）两种主要的表达式形式：
4. 前缀表达式： 运算符位于操作数之前。例如，中缀表达式 `3 + 4` 在前缀形式中写作 `+ 3 4`。
5. 后缀表达式： 运算符位于操作数之后。例如，中缀表达式 `3 + 4` 在后缀形式中写作 `3 4 +`。
6. 这两种形式（特别是后缀表达式）在计算机编程中非常有用，因为它们可以不使用括号就清晰地定义操作的顺序，便于计算机快速解析和计算，尤其是在栈结构的帮助下。
7. 总的来说，中缀表达式因其直观性在日常生活中被广泛使用，而在编程和计算领域，为了简化解析和计算过程，往往会转换为前缀或后缀表达式进行处理。

## 6、栈实现综合计算器（中缀表达式）

> 算式：((15 + 5.5) * (4 + 6) / 2 - (3 * (8 + 2.4) - 10) + 200) * (10 - 3) + 100 / (2 * 5) + 300 - (50 - 20) * 4 + (100 - (50 / 5)) = 2249.1

1. 创建两个栈，一个数栈，一个符号栈
2. 遍历我们的表达式：
3. 如果我们发现是一个数字，就直接入数栈
4. 如果发现扫描到是一个符号，就分如下情况
	1. 如果发现当前的符号栈为空，就直接入栈
	2. 如果符号栈有操作符，就进行比较：
		1. 如果当前的操作符的优先级小于或者等于核中的操作符，就需要从数核中 pop 出两个数，再从符号栈中 pop 出一个符号，进行运算，将得到的结果入数栈，然后将当前的操作符入符号栈
		2. 如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈
5. 当表达式扫描完毕，就顺序的从数栈和符号栈中 pop 出相应的数和符号，并运行
6. 最后在数栈只有一个数字，就是表达式的结果
7. 实例代码：

```java
package com.yuehai._04_stack;


import java.math.BigDecimal;
import java.math.RoundingMode;

/**
 * 计算器（中缀表达式）
 * @author 月海
 * @date 2024/7/1 11:27
 * @description 计算器（中缀表达式）
 */
public class CalculatorInfixExpression {
    public static void main(String[] args) {
        // 定义算式
        String expression = "((15 + 5.5) * (4 + 6) / 2 - (3 * (8 + 2.4) - 10) + 200) * (10 - 3) + 100 / (2 * 5) + 300 - (50 - 20) * 4 + (100 - (50 / 5))";
        // 去除表达式中的所有空格
        String newExpression = expression.replaceAll(" ", "");
        
        // 创建数栈，用于存放数；
        ArrayStack numStack = new ArrayStack(10);
        // 创建符号栈，用于存放符号
        ArrayStack operStack = new ArrayStack(10);
        // 用于拼接多位数的数字
        StringBuilder numberBuilder = new StringBuilder();
        
        // 遍历算式
        for (int i = 0; i < newExpression.length(); i++) {
            // 获取当前字符
            char ch = newExpression.charAt(i);
            
            // 判断当前字符是否是数字 或 小数点
            if (Character.isDigit(ch) || ch == '.'){
                // 如果当前字符是数字，则将当前字符添加到 numberBuilder 列表中
                numberBuilder.append(ch);
            }else if (ch == '-'){
                // 如果当前字符是减号，调用减号的逻辑
                minusLogic(numStack, operStack, numberBuilder, newExpression, i, ch);
            }else if(ch == '(' || ch == ')'){
                // 处理当前数字，将数字入栈，并清空 numberBuilder
                processNumber(numStack, numberBuilder);
                // 如果当前字符是括号，调用括号的逻辑
                bracketLogic(numStack, operStack, String.valueOf(ch));
            }else if (ch == '+' || ch == '*' || ch == '/'){
                // 处理当前数字，将数字入栈，并清空 numberBuilder
                processNumber(numStack, numberBuilder);
                // 符号入栈时的逻辑，将加号入符号栈
                operStackLogic(numStack, operStack, String.valueOf(ch));
            }else{
                throw new IllegalArgumentException("非法字符：" + ch);
            }
        }
        
        // 遍历完毕后，如果 numberBuilder 不为空，则将 numberBuilder 中的数字字符串入数栈，并清空 numberBuilder
        processNumber(numStack, numberBuilder);
        
        // 依次取出数栈中的数和符号栈中的符号进行运算
        while (!operStack.isEmpty()) {
            // 出栈两个数
            BigDecimal num1 = new BigDecimal(numStack.pop());
            BigDecimal num2 = new BigDecimal(numStack.pop());
            // 出栈一个符号
            String oper = operStack.pop();
            // 计算
            BigDecimal result = cal(num1, num2, oper);
            
            // 将结果入数栈
            numStack.push(String.valueOf(result));
        }
        
        // 最后数栈中的数就是结果
        System.out.println("表达式【 " + expression + " 】的结果是：" + numStack.pop());
    }
    
    /**
     * 处理数字字符串，将数字入栈，并清空 numberBuilder
     * @param numStack 数栈
     * @param numberBuilder 数字字符串构建器
     */
    private static void processNumber(ArrayStack numStack, StringBuilder numberBuilder) {
        if (!numberBuilder.isEmpty()) {
            numStack.push(numberBuilder.toString());
            numberBuilder.setLength(0);
        }
    }
    
    /**
     * 处理当前字符是减号时的逻辑
     * @param numStack 数栈
     * @param operStack 符号栈
     * @param numberBuilder 数字字符串构建器
     * @param newExpression 去除空格后的表达式
     * @param i 当前字符的索引
     * @param ch 当前字符
     * <p></p>
     * 将减法单独处理为加负数的原因是，如果减法后面跟着乘法、后面又跟着减法，会导致运算出错：
     * 如：250 - 3 * 2 - 3 = 250 - 6 - 3 = 241
     * 会变成：250 - 3 * 2 - 3 = 250 - （6 - 3） = 250 - 3 = 247
     */
    public static void minusLogic(ArrayStack numStack, ArrayStack operStack, StringBuilder numberBuilder, String newExpression, int i, char ch) {
        // 处理当前数字，将数字入栈，并清空 numberBuilder
        processNumber(numStack, numberBuilder);
        
        // 如果当前字符是是最后一个字符，直接退出
        if (i >= newExpression.length() - 1) {
            return;
        }
        
        // 不是最后一个字符，特殊情况处理：括号前的减号；转变为使用 -1 * 括号内的表达式，即：-（3 + 2） = -1 * (3 + 2)，以此来处理减号
        if (newExpression.charAt(i + 1) == '(') {
            // 将减号转化为加上一个负数，即将加号入符号栈
            operStackLogic(numStack, operStack, "+");
            // 数栈推入 -1，与括号内的表达式相乘
            numStack.push("-1");
            // 将乘号入符号栈，与括号内的表达式相乘
            operStackLogic(numStack, operStack, "*");
            return;
        }
        
        // 不是最后一个字符，且下一个字符是数字，则将减法单独处理为加负数
        if (Character.isDigit(newExpression.charAt(i + 1))) {
            // 符号入栈时的逻辑，将加号入符号栈
            operStackLogic(numStack, operStack, "+");
            // 继续拼接负数
            numberBuilder.append(ch);
        }else{
            // 当前字符是最后一位、或者下一位不是数字，表示不可以处理为负数，则正常作为减号处理
            operStackLogic(numStack, operStack, String.valueOf(ch));
        }
    }
    
    /**
     * 处理当前字符是括号时的逻辑
     * @param numStack 数栈
     * @param operStack 符号栈
     * @param ch 当前字符
     */
    public static void bracketLogic(ArrayStack numStack, ArrayStack operStack, String ch) {
        // 如果当前字符是左括号，直接入符号栈
        if ("(".equals(ch)) {
            operStack.push(ch);
            return;
        }
        
        // 如果当前字符是右括号，从符号栈中取出符号，直到取出左括号
        while (true){
            // 出栈一个符号
            String oper = operStack.pop();
            // 如果取出的符号是左括号，则结束循环
            if ("(".equals(oper)) {
                break;
            }
            
            // 如果取出的符号不是左括号，则出栈两个数，进行运算
            BigDecimal num1 = new BigDecimal(numStack.pop());
            BigDecimal num2 = new BigDecimal(numStack.pop());
            // 计算
            BigDecimal result = cal(num1, num2, oper);
            
            // 将结果入数栈
            numStack.push(String.valueOf(result));
        }
    }
    
    /**
     * 符号入栈时的逻辑
     * @param numStack 数栈
     * @param operStack 符号栈
     * @param ch 符号
     */
    public static void operStackLogic(ArrayStack numStack, ArrayStack operStack, String ch) {
        // 如果符号栈为空，则直接入栈
        if (operStack.isEmpty()) {
            operStack.push(ch);
            return;
        }
        
        // 如果符号栈不为空
        // 如果当前符号的优先级小于等于栈顶符号的优先级，则从数栈中取出两个数，从符号栈中取出一个符号进行运算，将结果入数栈，当前符号入符号栈
        if (priority(ch) <= priority(operStack.peek())) {
            // 出栈两个数
            BigDecimal num1 = new BigDecimal(numStack.pop());
            BigDecimal num2 = new BigDecimal(numStack.pop());
            // 出栈一个符号
            String oper = operStack.pop();
            // 计算
            BigDecimal result = cal(num1, num2, oper);
            
            // 将结果入数栈
            numStack.push(String.valueOf(result));
            // 当前符号入符号栈
            operStack.push(ch);
        } else {
            // 如果当前符号的优先级大于栈顶符号的优先级，则直接入符号栈
            operStack.push(ch);
        }
    }
    
    /**
     * 判断符号的优先级
     * @param oper 符号
     * @return 优先级
     */
    public static int priority(String oper) {
        return switch (oper) {
            case "*", "/" -> 2;
            case "+", "-" -> 1;
            case "(", ")" -> 0;
            default -> -1;
        };
    }
    
    /**
     * 计算
     * @param num1 数 1
     * @param num2 数 2
     * @param oper 符号
     * @return 计算结果
     */
    public static BigDecimal cal(BigDecimal num1, BigDecimal num2, String oper) {
        return switch (oper) {
            case "+" -> num1.add(num2);
            case "-" -> num2.subtract(num1);
            case "*" -> num1.multiply(num2);
            case "/" -> {
                if (num1.compareTo(BigDecimal.ZERO) == 0) {
                    throw new ArithmeticException("除数不能为0");
                }
                /*
                    yield：在 Java 13 中引入，用于返回值；和 return 一样，但是 yield 可以在 switch 表达式中使用
                    divide：除法；
                        参数 1：除数，即分号下面的数；
                        参数 2：保留小数位数；
                        参数 3：舍入模式，这里使用四舍五入
                    stripTrailingZeros：去除尾部的 0
                 */
                yield num2.divide(num1, 10, RoundingMode.HALF_UP).stripTrailingZeros();
            }
            default -> throw new IllegalArgumentException("非法操作符：" + oper);
        };
    }
    
}
```

8. 结果：

```shell
表达式【 ((15 + 5.5) * (4 + 6) / 2 - (3 * (8 + 2.4) - 10) + 200) * (10 - 3) + 100 / (2 * 5) + 300 - (50 - 20) * 4 + (100 - (50 / 5)) 】的结果是：2249.1

进程已结束，退出代码为 0
```

## 7、中缀表达式转换为后缀表达式（逆波兰表达式）

### ①、具体步骤

1. 初始化两个栈：运算符栈 s1 和储存中间结果的栈 s2
2. 从左至右扫描中缀表达式
3. 遇到操作数时，将其压 s2
4. 遇到运算符时，比较其与 s1 栈顶运算符的优先级：
	1. 如果 s1 为空、或栈顶运算符为左括号 `(` 则直接将此运算符压入 s1
	2. 否则，判断当前运算符和栈顶运算符的优先级：
		1. 当前运算符的优先级比栈顶运算符的优先级高，则也直接将此运算符压入 s1
		2. 否则，将 s1 栈顶的运算符弹出并压入到 s2 中，再次转到 4.1 与 s1 中新的栈顶运算符相比较；
5. 遇到括号时：
	1. 如果是左括号 `(`，则直接压入 s1
	2. 如果是右括号 `)`，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号 `(` 为止，此时将这一对括号丢弃
6. 重复步骤 2 至 5，直到表达式的最右边
7. 将 s1 中剩余的运算符依次弹出并压入 s2
8. 依次弹出 s2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式

### ②、举例说明

1. 将中缀表达式 `1 + ( ( 2.5 + 3 ) * 4 ) - 5.3` 转换为后缀表达式的过程如下
2. 结果为：`1 2.5 3 + 4 * + 5.3 –`

| 扫描到的元素 | s2(栈底->栈顶)            | s1 (栈底->栈顶) | 说明                       |
| ------ | --------------------- | ----------- | ------------------------ |
| 1      | 1                     | 空           | 数字，直接入栈                  |
| +      | 1                     | +           | s1 为空，运算符直接入栈            |
| (      | 1                     | + (         | 左括号，直接入栈                 |
| (      | 1                     | + ((        | 同上                       |
| 2.5    | 1 2.5                 | + ((        | 数字                       |
| +      | 1 2.5                 | + (( +      | s1 栈顶为左括号，运算符直接入栈        |
| 3      | 1 2.5 3               | + (( +      | 数字                       |
| )      | 1 2.5 3 +             | + (         | 右括号，弹出运算符直至遇到左括号         |
| *      | 1 2.5 3 +             | + ( *       | s1 栈顶为左括号，运算符直接入栈        |
| 4      | 1 2.5 3 + 4           | + ( *       | 数字                       |
| )      | 1 2.5 3 + 4 *         | +           | 右括号，弹出运算符直至遇到左括号         |
| -      | 1 2.5 3 + 4 * +       | -           | - 与 + 优先级相同，因此弹出 +，再入栈 - |
| 5.3    | 1 2.5 3 + 4 * + 5.3   | -           | 数字                       |
| 到达最右端  | 1 2.5 3 + 4 * + 5.3 - | 空           | s1 中剩余的运算符               |

### ③、实例代码

1. 实例代码

```java
package com.yuehai._04_stack;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Arrays;

/**
 * 计算器（后缀表达式、逆波兰表达式）
 * @author 月海
 * @date 2024/7/3 16:37
 * @description 计算器（后缀表达式、逆波兰表达式）
 */
public class CalculatorPostfixExpression {
    public static void main(String[] args) {
        // 定义算式
        String expression = "1 + ( ( 2.5 + 3 ) × 4 ) - 5.3";
        // 去除表达式中的所有空格
        String newExpression = expression.replaceAll(" ", "");
        // 中缀表达式转后缀表达式
        String[] infixToPostfix = infixToPostfix(newExpression);
        
        System.out.println("原始中缀表达式：" + expression);
        System.out.println("后缀表达式：" + Arrays.toString(infixToPostfix));
    
    }
    
    /**
     * 中缀表达式转后缀表达式
     */
    public static String[] infixToPostfix(String expression) {
        // 初始化符号栈
        ArrayStack operStack = new ArrayStack(10);
        // 初始化中间结果栈
        ArrayStack resultStack = new ArrayStack(expression.length());
        // 用于拼接多位数的数字
        StringBuilder numberBuilder = new StringBuilder();
        // 记录中间结果栈中的元素数量
        int resultStackSize = 0;
        
        // 遍历算式
        for (int i = 0; i < expression.length(); i++) {
            // 获取当前字符
            char ch = expression.charAt(i);
            
            // 判断当前字符是否是数字 或 小数
            if (Character.isDigit(ch) || ch == '.') {
                // 如果当前字符是数字，则将当前字符添加到 numberBuilder 列表中
                numberBuilder.append(ch);
                // 终止本次循环
                continue;
            }
            
            // 当前字符不是数字，处理数字字符串，将数字入栈，并清空 numberBuilder
            resultStackSize = processNumber(resultStack, numberBuilder, resultStackSize);
            
            // 当前字符是左括号 (，直接入栈
            if (ch == '(') {
                operStack.push(String.valueOf(ch));
                // 终止本次循环
                continue;
            }
            
            // 当前字符是右括号 )
            if (ch == ')') {
                // 循环取出符号栈中的符号，直到遇到左括号 (
                while (!"(".equals(operStack.peek())) {
                    // 出栈一个运算符
                    String oper = operStack.pop();
                    // 将运算符入中间结果栈
                    resultStack.push(oper);
                    // 中间结果栈中的元素数量加 1
                    resultStackSize++;
                }
                // 将左括号 ( 出栈
                operStack.pop();
                // 终止本次循环
                continue;
            }
            
            // 当前字符不是数字或括号，判断符号栈是否为空 或 栈顶符号是否为左括号 ( 或 当前运算符优先级是否大于栈顶运算符优先级
            if(operStack.isEmpty() || "(".equals(operStack.peek()) || priority(String.valueOf(ch)) > priority(operStack.peek())){
                // 符号栈为空 或 栈顶符号为左括号 (，直接入栈
                operStack.push(String.valueOf(ch));
                // 终止本次循环
                continue;
            }
            
            // 当前字符不是数字或括号，且符号栈不为空，且栈顶符号不是左括号 (，且当前运算符优先级小于等于栈顶运算符优先级
            do {
                // 出栈一个运算符
                String oper = operStack.pop();
                // 将运算符入中间结果栈
                resultStack.push(oper);
                // 中间结果栈中的元素数量加 1
                resultStackSize++;
                
            // 如果符号栈不为空 且 栈顶符号不是左括号 ( 且 当前运算符优先级小于等于栈顶运算符优先级，则继续循环：出栈运算符，入中间结果栈
            }while (!operStack.isEmpty() && !"(".equals(operStack.peek()) && priority(String.valueOf(ch)) <= priority(operStack.peek()));
            
            /*
                经过上面的循环后，当前运算符的优先级大于栈顶运算符的优先级，或者符号栈为空，或者栈顶符号是左括号 (，
                则将当前运算符入符号栈
             */
            operStack.push(String.valueOf(ch));
        }
        
        // 遍历完毕后，处理数字字符串，将数字入栈，并清空 numberBuilder
        resultStackSize = processNumber(resultStack, numberBuilder, resultStackSize);
        
        // 将符号栈中的符号依次出栈，入中间结果栈
        while (!operStack.isEmpty()) {
            resultStack.push(operStack.pop());
            resultStackSize++;
        }
        
        // 创建一个数组，用于存放倒序的中间结果栈中的元素
        String[] resultArray = new String[resultStackSize];
        // 将中间结果栈中的元素倒序存放到数组中
        for (int i = resultStackSize - 1; i >= 0; i--) {
            resultArray[i] = resultStack.pop();
        }
        
        return resultArray;
    }
    
    /**
     * 处理数字字符串，将数字入栈，并清空 numberBuilder
     * @param resultStack 中间结果栈
     * @param numberBuilder 数字字符串构建器
     * @param resultStackSize 中间结果栈中的元素数量
     */
    private static int processNumber(ArrayStack resultStack, StringBuilder numberBuilder, int resultStackSize) {
        if (!numberBuilder.isEmpty()) {
            resultStack.push(numberBuilder.toString());
            numberBuilder.setLength(0);
            resultStackSize++;
        }
        
        return resultStackSize;
    }
    
    /**
     * 判断符号的优先级
     * @param oper 符号
     * @return 优先级
     */
    public static int priority(String oper) {
        return switch (oper) {
            case "*", "/" -> 2;
            case "+", "-" -> 1;
            case "(", ")" -> 0;
            default -> -1;
        };
    }
    
}
```

2. 结果

```shell
原始中缀表达式：1 + ( ( 2.5 + 3 ) × 4 ) - 5.3
后缀表达式：[1, 2.5, 3, +, 4, ×, +, 5.3, -]

进程已结束，退出代码为 0
```

## 8、逆波兰计算器

1. 后缀表达式的计算机求值：从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果
2. 例如: `1 + ( ( 2.5 + 3 ) × 4 ) - 5.3` 对应的后缀表达式就是 `1 2.5 3 + 4 x + 5.3 -` , 针对后缀表达式求值步骤如下:
	1. 从左至右扫描，将 1、2.5 和 3 压入堆栈
		1. 此时栈中的元素为：`1 2.5 3`
	2. 遇到 + 运算符，因此弹出 3 和 2.5（3 为栈顶元素，2.5 为次顶元素），计算出 `3 + 2.5` 的值，得 `5.5`，再将 5.5 入栈；
		1. 此时栈中的元素为：`1 5.5`
	3. 将 4 入栈；
		1. 此时栈中的元素为：`1 5.5 4`
	4. 接下来是 × 运算符，因此弹出 4 和 5.5，计算出 ` 4 × 5.5 = 22`，将 `22` 入栈；
		1. 此时栈中的元素为：`1 22`
	5. 接下来是 + 运算符，因此弹出 22 和 1，计算出 ` 22 + 1 = 23`，将 `23` 入栈；
		1. 此时栈中的元素为：`23`
	6. 将 5.3 入栈；
		1. 此时栈中的元素为：`23 5.3`
	7. 最后是 - 运算符，计算出 `23 - 5.3` 的值，即 `17.7`，由此得出最终结果
3. 代码实例：

```java
package com.yuehai._04_stack;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Arrays;

/**
 * 计算器（后缀表达式、逆波兰表达式）
 * @author 月海
 * @date 2024/7/3 16:37
 * @description 计算器（后缀表达式、逆波兰表达式）
 */
public class CalculatorPostfixExpression {
    public static void main(String[] args) {
        // 定义算式：1 + ( ( 2.5 + 3 ) * 4 ) - 5.3 = 17.7
        String expression = "1 + ( ( 2.5 + 3 ) * 4 ) - 5.3";
        // 去除表达式中的所有空格
        String newExpression = expression.replaceAll(" ", "");
        // 中缀表达式转后缀表达式
        String[] infixToPostfix = infixToPostfix(newExpression);
        
        System.out.println("原始中缀表达式：" + expression);
        System.out.println("后缀表达式：" + Arrays.toString(infixToPostfix));
        
        // 创建数栈，用于存放数；
        ArrayStack numStack = new ArrayStack(10);
        
        // 遍历后缀表达式
        for (String item : infixToPostfix) {
            // 判断当前字符是否是数字
            if (item.matches("\\d+(\\.\\d+)?")) {
                // 如果当前字符是数字，则将当前字符入数栈
                numStack.push(item);
            } else {
                // 如果当前字符是符号，则从数栈中取出两个数，进行运算
                BigDecimal num1 = new BigDecimal(numStack.pop());
                BigDecimal num2 = new BigDecimal(numStack.pop());
                // 计算结果
                BigDecimal cal = cal(num1, num2, item);
                // 将计算结果入数栈
                numStack.push(cal.toString());
            }
        }
        
        // 最后数栈中只有一个元素，即为计算结果
        System.out.println("计算结果：" + numStack.pop());
    }
    
    /**
     * 中缀表达式转后缀表达式
     */
    public static String[] infixToPostfix(String expression) {
        // 初始化符号栈
        ArrayStack operStack = new ArrayStack(10);
        // 初始化中间结果栈
        ArrayStack resultStack = new ArrayStack(expression.length());
        // 用于拼接多位数的数字
        StringBuilder numberBuilder = new StringBuilder();
        // 记录中间结果栈中的元素数量
        int resultStackSize = 0;
        
        // 遍历算式
        for (int i = 0; i < expression.length(); i++) {
            // 获取当前字符
            char ch = expression.charAt(i);
            
            // 判断当前字符是否是数字 或 小数
            if (Character.isDigit(ch) || ch == '.') {
                // 如果当前字符是数字，则将当前字符添加到 numberBuilder 列表中
                numberBuilder.append(ch);
                // 终止本次循环
                continue;
            }
            
            // 当前字符不是数字，处理数字字符串，将数字入栈，并清空 numberBuilder
            resultStackSize = processNumber(resultStack, numberBuilder, resultStackSize);
            
            // 当前字符是左括号 (，直接入栈
            if (ch == '(') {
                operStack.push(String.valueOf(ch));
                // 终止本次循环
                continue;
            }
            
            // 当前字符是右括号 )
            if (ch == ')') {
                // 循环取出符号栈中的符号，直到遇到左括号 (
                while (!"(".equals(operStack.peek())) {
                    // 出栈一个运算符
                    String oper = operStack.pop();
                    // 将运算符入中间结果栈
                    resultStack.push(oper);
                    // 中间结果栈中的元素数量加 1
                    resultStackSize++;
                }
                // 将左括号 ( 出栈
                operStack.pop();
                // 终止本次循环
                continue;
            }
            
            // 当前字符不是数字或括号，判断符号栈是否为空 或 栈顶符号是否为左括号 ( 或 当前运算符优先级是否大于栈顶运算符优先级
            if(operStack.isEmpty() || "(".equals(operStack.peek()) || priority(String.valueOf(ch)) > priority(operStack.peek())){
                // 符号栈为空 或 栈顶符号为左括号 (，直接入栈
                operStack.push(String.valueOf(ch));
                // 终止本次循环
                continue;
            }
            
            // 当前字符不是数字或括号，且符号栈不为空，且栈顶符号不是左括号 (，且当前运算符优先级小于等于栈顶运算符优先级
            do {
                // 出栈一个运算符
                String oper = operStack.pop();
                // 将运算符入中间结果栈
                resultStack.push(oper);
                // 中间结果栈中的元素数量加 1
                resultStackSize++;
                
            // 如果符号栈不为空 且 栈顶符号不是左括号 ( 且 当前运算符优先级小于等于栈顶运算符优先级，则继续循环：出栈运算符，入中间结果栈
            }while (!operStack.isEmpty() && !"(".equals(operStack.peek()) && priority(String.valueOf(ch)) <= priority(operStack.peek()));
            
            /*
                经过上面的循环后，当前运算符的优先级大于栈顶运算符的优先级，或者符号栈为空，或者栈顶符号是左括号 (，
                则将当前运算符入符号栈
             */
            operStack.push(String.valueOf(ch));
        }
        
        // 遍历完毕后，处理数字字符串，将数字入栈，并清空 numberBuilder
        resultStackSize = processNumber(resultStack, numberBuilder, resultStackSize);
        
        // 将符号栈中的符号依次出栈，入中间结果栈
        while (!operStack.isEmpty()) {
            resultStack.push(operStack.pop());
            resultStackSize++;
        }
        
        // 创建一个数组，用于存放倒序的中间结果栈中的元素
        String[] resultArray = new String[resultStackSize];
        // 将中间结果栈中的元素倒序存放到数组中
        for (int i = resultStackSize - 1; i >= 0; i--) {
            resultArray[i] = resultStack.pop();
        }
        
        return resultArray;
    }
    
    /**
     * 处理数字字符串，将数字入栈，并清空 numberBuilder
     * @param resultStack 中间结果栈
     * @param numberBuilder 数字字符串构建器
     * @param resultStackSize 中间结果栈中的元素数量
     */
    private static int processNumber(ArrayStack resultStack, StringBuilder numberBuilder, int resultStackSize) {
        if (!numberBuilder.isEmpty()) {
            resultStack.push(numberBuilder.toString());
            numberBuilder.setLength(0);
            resultStackSize++;
        }
        
        return resultStackSize;
    }
    
    /**
     * 判断符号的优先级
     * @param oper 符号
     * @return 优先级
     */
    public static int priority(String oper) {
        return switch (oper) {
            case "*", "/" -> 2;
            case "+", "-" -> 1;
            case "(", ")" -> 0;
            default -> -1;
        };
    }
    
    /**
     * 计算
     * @param num1 数 1
     * @param num2 数 2
     * @param oper 符号
     * @return 计算结果
     */
    public static BigDecimal cal(BigDecimal num1, BigDecimal num2, String oper) {
        return switch (oper) {
            case "+" -> num1.add(num2);
            case "-" -> num2.subtract(num1);
            case "*" -> num1.multiply(num2);
            case "/" -> {
                if (num1.compareTo(BigDecimal.ZERO) == 0) {
                    throw new ArithmeticException("除数不能为0");
                }
                /*
                    yield：在 Java 13 中引入，用于返回值；和 return 一样，但是 yield 可以在 switch 表达式中使用
                    divide：除法；
                        参数 1：除数，即分号下面的数；
                        参数 2：保留小数位数；
                        参数 3：舍入模式，这里使用四舍五入
                    stripTrailingZeros：去除尾部的 0
                 */
                yield num2.divide(num1, 10, RoundingMode.HALF_UP).stripTrailingZeros();
            }
            default -> throw new IllegalArgumentException("非法操作符：" + oper);
        };
    }
    
}
```

4. 结果：

```shell
原始中缀表达式：1 + ( ( 2.5 + 3 ) * 4 ) - 5.3
后缀表达式：[1, 2.5, 3, +, 4, *, +, 5.3, -]
计算结果：17.7

进程已结束，退出代码为 0
```

# 五、递归

## 1、递归的介绍

1. 递归是一种在程序设计中常用的方法，它允许函数调用自身。这种技术通常用于解决可以分解为相似子问题的问题，特别是在数据结构如树和图中处理问题时非常有效。
2. 递归函数的基本结构包括两个部分：基础情况（递归停止的条件）和递归步骤（函数调用自身）。
	1. 基础情况是必须的，以防止无限递归，导致程序崩溃。
	2. 每次递归调用都应该使问题朝着基础情况进展。
3. 举个简单的例子，计算阶乘通常使用递归方法。阶乘函数的定义是：任何数的阶乘等于该数乘以其前一个数的阶乘，而 `0!` 定义为 1。这里，`0!` 就是递归的基础情况。
4. 递归虽然在某些情况下非常有用，但也要注意其可能引起的问题，如栈溢出错误。此外，递归函数通常比其迭代版本运行效率低，因为递归函数需要多次调用自身，而每次调用都涉及到栈操作等额外开销。因此，在实际应用中，需要根据具体情况选择使用递归或迭代。

## 2、递归的应用场景

1. 数据结构操作：
	1. 树的遍历和操作：在二叉树或其他树形数据结构中，递归是进行前序、中序、后序遍历的自然选择。例如，搜索特定节点、插入新节点和删除节点通常用递归实现。
	2. 图的遍历：在图形数据结构中，如深度优先搜索（DFS）经常使用递归。
2. 算法：
	1. 分治算法：递归是实现分治策略的核心技术，如快速排序和归并排序。这些算法将数据分为较小的部分，独立解决，然后将结果合并。
	2. 动态规划：某些类型的动态规划问题，如计算斐波那契数列，可以通过递归实现，尽管为了提高效率，通常会加入记忆化或改为迭代形式。
3. 数学问题：
	1. 阶乘计算：如前所述，阶乘函数的定义本身就是递归的。
	2. 幂运算：计算一个数的幂可以通过递归快速实现，例如使用“快速幂”算法。
4. 组合问题：
	1. 排列组合：递归可以用来生成特定条件下的所有可能排列或组合。
	2. 括号生成：生成所有有效的括号组合是递归的一个典型例子。
5. 解决具体问题：
	1. 迷宫求解：在迷宫问题中，从一个点到另一个点的路径探索可以通过递归实现。
	2. 回溯算法：用于解决约束满足问题，如数独、八皇后问题等，通常通过递归实现试错过程。
6. 递归方法因其将问题简化为可管理的子问题而非常强大，但也要注意其对内存的使用，特别是在深层递归调用中可能导致的栈溢出问题。

## 3、递归需要遵守的重要规则

1. 执行一个方法时，就创建一个新的受保护的独立空间(栈空间)
2. 方法的局部变量是独立的，不会相互影响
3. 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据
4. 递归必须向退出递归的条件逼近，否则就是无限递归，出现StackOverflowError
5. 当一个方法执行完毕，或者遇到 return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。
6. 实例代码：

```java
package com.yuehai._05_recursion;

/**
 * 递归打印
 * @author 月海
 * @date 2024/7/12 15:46
 * @description 递归打印
 */
public class RecursionDemo {
    public static void main(String[] args) {
        // 递归打印
        test(4);
    }
    
    /**
     * 递归打印
     * @param n 数值
     */
    public static void test(int n) {
        // 如果 n 大于 2 就继续递归
        if (n > 2) {
            // 递归
            test(n - 1);
        }
        System.out.println("n = " + n);
    }
}
```

7. 结果：

```shell
n = 2
n = 3
n = 4

进程已结束，退出代码为 0
```

8. 图解

![|531](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240712155004.png)

## 4、迷宫问题

### ①、迷宫问题介绍

1.  迷宫问题是一个经典的递归问题：
2. 给定一个二维数组 `new int[8][7]`，表示一个迷宫。
3. `1` 表示墙，`0` 表示可以走，`2` 表示通路可以走，`3` 表示该点已经走过但是走不通。
4. 起点是 `(1, 1)`，终点是 `(6, 5)`。
5. 走迷宫时，需要确定一个策略（方法），如：下 -> 右 -> 上 -> 左，如果该点走不通，再回溯。

![|292](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240715145605.png)

### ②、迷宫问题代码实现与详解

1. 迷宫问题的递归思想：在这个迷宫问题中，我们设定一个起点和一个终点，任务是找到从起点到终点的路径。递归在这里起到的作用是尝试每一种可能的步骤组合，直到找到出口。
2. 递归终止条件：在迷宫问题中，递归的终止条件是到达终点（`map[6][5] == 2`）。如果到达了终点，递归就会停止，表示找到了一条通路。
3. 递归的执行过程：
	1. 当前位置检查：首先检查当前位置是否为 0（可以走的路）。如果不是 0，则当前位置不能走，递归立即返回 false。
	2. 选择路径：如果当前位置可以走（即，为 0），我们假设这条路是可以通过的，暂时将其标记为2（通路）。
	3. 递归尝试：从当前位置开始，按照策略（下 -> 右 -> 上 -> 左）尝试每个方向：
	4. 向下走：调用 `setWay(map, i + 1, j)`。如果返回 true，说明找到了一条通路，当前递归返回 true。
	5. 向右走：如果向下不通，则尝试向右走，调用 `setWay(map, i, j + 1)`，同样，如果返回 true，说明找到了通路。
	6. 向上走：向下和向右都不通时，尝试向上走。
	7. 向左走：最后尝试向左走。
4. 回溯处理：如果所有方向都尝试后都没有找到通路，那么假设当前位置其实是不可通过的，将其标记为3（走不通的路），并返回 false。
5. 递归的核心：
	1. 尝试与回溯：递归过程中的每一步都是一个尝试，如果尝试失败了，就回溯到上一步，尝试另一种可能。
	2. 路径的标记：在递归过程中，通过 2 和 3 来标记路径状态，帮助避免重复走同一路径，同时记录哪些路径是尝试过而失败的。
6. 实例代码：

```jav
package com.yuehai._05_recursion;

/**
 * 迷宫问题
 * @author 月海
 * @date 2024/7/15 9:33
 * @description 迷宫问题
 * <p></p>
 * 迷宫问题是一个经典的递归问题：
 * 给定一个二维数组 new int[8][7]，表示一个迷宫。
 * 1 表示墙，0 表示可以走，2 表示通路可以走，3 表示该点已经走过但是走不通。
 * 起点是 (1, 1)，终点是 (6, 5)。
 * 走迷宫时，需要确定一个策略（方法），如：下 -> 右 -> 上 -> 左，如果该点走不通，再回溯。
 * 迷宫地图如下：
 * 1 1 1 1 1 1 1
 * 1 0 0 0 0 0 1
 * 1 0 0 0 0 0 1
 * 1 1 1 0 0 0 1
 * 1 0 0 0 0 0 1
 * 1 0 0 0 0 0 1
 * 1 0 0 0 0 0 1
 * 1 1 1 1 1 1 1
 */
public class MazeProblem {
    public static void main(String[] args) {
        // 创建一个二维数组，模拟迷宫
        int[][] map = new int[8][7];
        // 使用 1 表示墙，上下全部置为 1
        for (int i = 0; i < 7; i++) {
            map[0][i] = 1;
            map[7][i] = 1;
        }
        // 左右全部置为 1
        for (int i = 0; i < 8; i++) {
            map[i][0] = 1;
            map[i][6] = 1;
        }
        // 设置挡板，1 表示
        map[3][1] = 1;
        map[3][2] = 1;
        
        // 输出地图
        System.out.println("地图的情况：");
        for (int[] row : map) {
            for (int value : row) {
                System.out.print(value + " ");
            }
            System.out.println();
        }
        
        // 使用递归回溯给小球找路
        setWay(map, 1, 1);
        
        // 输出新的地图，小球走过并标识过的地图
        System.out.println("小球走过并标识过的地图：");
        for (int[] row : map) {
            for (int value : row) {
                System.out.print(value + " ");
            }
            System.out.println();
        }
    }
    
    /**
     * 使用递归回溯给小球找路
     * @param map 地图
     * @param i 表示从地图的哪个位置开始出发（1，1）
     * @param j 表示从地图的哪个位置开始出发（1，1）
     * @return 如果找到通路，返回 true，否则返回 false
     * <p></p>
     * 说明：
     * 1. map 表示地图
     * 2. i，j 表示从地图的哪个位置开始出发（1，1）
     * 3. 如果小球能到 map[6][5] 位置，则说明通路找到
     * 4. 约定：当 map[i][j] 为 0 表示该点没有走过，当为 1 表示墙，2 表示通路可以走，3 表示该点已经走过但是走不通
     * 5. 在走迷宫时，需要确定一个策略（方法）：下 -> 右 -> 上 -> 左，如果该点走不通，再回溯
     * <p></p>
     * 在这个迷宫问题中，小球是先走到最底层，然后再回溯，所以这个问题是一个典型的递归问题
     */
    public static boolean setWay(int[][] map, int i, int j) {
        // 若 map[6][5] 为 2，说明通路已经找到
        if (map[6][5] == 2) {
            return true;
        } else {
            // 若当前这个点还没有走过
            if (map[i][j] == 0) {
                // 假定该点是可以走通的，在走之前先标记为 2，然后从该点开始按照策略走：下 -> 右 -> 上 -> 左
                map[i][j] = 2;
                if (setWay(map, i + 1, j)) {
                    // 向下走
                    return true;
                } else if (setWay(map, i, j + 1)) {
                    // 向右走
                    return true;
                } else if (setWay(map, i - 1, j)) {
                    // 向上走
                    return true;
                } else if (setWay(map, i, j - 1)) {
                    // 向左走
                    return true;
                } else {
                    // 说明该点是走不通的，是死路
                    map[i][j] = 3;
                    return false;
                }
            } else {
                // 如果 map[i][j] != 0，可能是 1，2，3
                return false;
            }
        }
    }
    
}
```

7. 结果：

```shell
地图的情况：
1 1 1 1 1 1 1 
1 0 0 0 0 0 1 
1 0 0 0 0 0 1 
1 1 1 0 0 0 1 
1 0 0 0 0 0 1 
1 0 0 0 0 0 1 
1 0 0 0 0 0 1 
1 1 1 1 1 1 1 
小球走过并标识过的地图：
1 1 1 1 1 1 1 
1 2 0 0 0 0 1 
1 2 2 2 0 0 1 
1 1 1 2 0 0 1 
1 0 0 2 0 0 1 
1 0 0 2 0 0 1 
1 0 0 2 2 2 1 
1 1 1 1 1 1 1 

进程已结束，退出代码为 0
```

### ③、求出最短路径（暂时的写法）

1. 将二位数组组成的表格做修改，左下角为 `(0, 0)`，右上角为 `(6, 7)`，即设置起点为 `(1, 1)`，终点为 `(4, 5)`
2. 这样设置的好处是，和平面直角坐标系一样，可以根据坐标的正负值来判断方向

![|430](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240716134112.png)

3. 在这个代码中，先判断小球当前位置和终点的相对位置，然后根据相对位置调整策略。
	1. 如果小球和终点在同一行或同一列，优先考虑水平或垂直方向，再考虑另一个方向。
	2. 如果小球和终点不在同一行或同一列，优先考虑垂直方向，再考虑水平方向。
4. 实例代码：

```java
package com.yuehai._05_recursion;

/**
 * 迷宫问题最短路径
 * @author 月海
 * @date 2024/7/15 15:55
 * @description 迷宫问题最短路径
 * <p></p>
 * 将二位数组组成的表格做修改，左下角为 (0, 0)，右上角为 (6, 7)，即设置起点为 (1, 1)，终点为 (4, 5)
 * 这样设置的好处是，和平面直角坐标系一样，可以根据坐标的正负值来判断方向
 */
public class MazeProblemShortestPath {
    public static void main(String[] args) {
        // 创建一个二维数组，模拟迷宫
        int[][] map = new int[7][8];
        // 使用 1 表示墙，上下全部置为 1
        for (int i = 0; i < 7; i++) {
            map[i][0] = 1;
            map[i][7] = 1;
        }
        // 左右全部置为 1
        for (int i = 0; i < 8; i++) {
            map[0][i] = 1;
            map[6][i] = 1;
        }
        // 设置挡板，1 表示
        map[1][3] = 1;
        map[2][3] = 1;
        
        // 输出地图，从左上角开始输出
        System.out.println("地图的情况：");
        for (int i = map[0].length - 1; i >= 0; i--) {
            for (int[] ints : map) {
                System.out.print(ints[i] + " ");
            }
            System.out.println();
        }
        
        // 使用递归回溯给小球找路；从 (1, 1) 到 (4, 5)
        setWay(map, 1, 1, 4, 5);

        // 输出新的地图，小球走过并标识过的地图
        System.out.println("小球走过并标识过的地图：");
        for (int i = map[0].length - 1; i >= 0; i--) {
            for (int[] ints : map) {
                System.out.print(ints[i] + " ");
            }
            System.out.println();
        }
    }
    
    /**
     * 使用递归回溯给小球找路
     * @param map 地图
     * @param x 表示从地图的哪个位置开始出发（1，1），横坐标
     * @param y 表示从地图的哪个位置开始出发（1，1），纵坐标
     * @param destinationX 终点横坐标
     * @param destinationY 终点纵坐标
     * @return 如果找到通路，返回 true，否则返回 false
     * <p></p>
     * 在这个代码中，先判断小球当前位置和终点的相对位置，然后根据相对位置调整策略。
     * 如果小球和终点在同一行或同一列，优先考虑水平或垂直方向，再考虑另一个方向。
     * 如果小球和终点不在同一行或同一列，优先考虑垂直方向，再考虑水平方向。
     */
    public static boolean setWay(int[][] map, int x, int y, int destinationX, int destinationY) {
        // 若终点坐标的值为 2，说明通路已经找到
        if (map[destinationX][destinationY] == 2) {
            return true;
        }
        
        // 如果 map[x][y] != 0，可能是 1，2，3，说明该点已经走过，不需要再走
        if(map[x][y] != 0){
            return false;
        }
        
        // 当前小球和终点的水平距离，正数表示小球在终点右侧，负数表示小球在终点左侧
        int distanceX = destinationX - x;
        // 当前小球和终点的垂直距离，正数表示小球在终点下方，负数表示小球在终点上方
        int distanceY = destinationY - y;

        // 假设该点可走
        map[x][y] = 2;
        
        /*
            根据当前位置相对终点的位置动态调整策略
            如果 distanceY == 0，表示小球和终点在同一列
            此时，优先考虑水平方向，根据 distanceX 的正负来决定向左还是向右走
            若左右走不通，再考虑垂直方向
         */
        if (distanceY == 0){
            if (
                    // 向左走
                    distanceX < 0 && setWay(map, x - 1, y, destinationX, destinationY) ||
                    // 向右走
                    distanceX > 0 && setWay(map, x + 1, y, destinationX, destinationY) ||
                    // 向上走
                    setWay(map, x, y + 1, destinationX, destinationY) ||
                    // 向下走
                    setWay(map, x, y - 1, destinationX, destinationY)
            ) {
            /*
                如果向下走不通，代码会尝试向右走。
                检查当前列号 y 是否小于最右列的列号5。
                如果可以，同样递归调用 setWay 函数尝试从右边的点继续寻找路径。如果成功，递归链返回 true。
             */
                return true;
            }else {
                // 死路，标记为 3
                map[x][y] = 3;
                return false;
            }
        }
        
        /*
            如果 distanceX == 0，表示小球和终点在同一行
            此时，优先考虑垂直方向，根据 distanceY 的正负来决定向上还是向下走
            若上下走不通，再考虑水平方向
         */
        if (distanceX == 0){
            if (
                    // 向上走
                    distanceY > 0 && setWay(map, x, y + 1, destinationX, destinationY) ||
                    // 向下走
                    distanceY < 0 && setWay(map, x, y - 1, destinationX, destinationY) ||
                    // 向左走
                    setWay(map, x - 1, y, destinationX, destinationY) ||
                    // 向右走
                    setWay(map, x + 1, y, destinationX, destinationY)
            ) {
            /*
                如果向下走不通，代码会尝试向右走。
                检查当前列号 y 是否小于最右列的列号5。
                如果可以，同样递归调用 setWay 函数尝试从右边的点继续寻找路径。如果成功，递归链返回 true。
             */
                return true;
            }else {
                // 死路，标记为 3
                map[x][y] = 3;
                return false;
            }
        }
        
        /*
            以下是小球和终点不在同一行或同一列的情况
            优先考虑垂直方向，根据 distanceY 的正负来决定向上还是向下走
         */
        if(
                // 向上走
                distanceY > 0 && setWay(map, x, y + 1, destinationX, destinationY) ||
                // 向下走
                distanceY < 0 && setWay(map, x, y - 1, destinationX, destinationY) ||
                // 向左走
                distanceX < 0 && setWay(map, x - 1, y, destinationX, destinationY) ||
                // 向右走
                distanceX > 0 && setWay(map, x + 1, y, destinationX, destinationY)
        ){
            return true;
        }else {
            // 死路，标记为 3
            map[x][y] = 3;
            return false;
        }
        
    }
    
    
}
```

5. 结果：

```shell
地图的情况：
1 1 1 1 1 1 1 
1 0 0 0 0 0 1 
1 0 0 0 0 0 1 
1 0 0 0 0 0 1 
1 1 1 0 0 0 1 
1 0 0 0 0 0 1 
1 0 0 0 0 0 1 
1 1 1 1 1 1 1 
小球走过并标识过的地图：
1 1 1 1 1 1 1 
1 0 0 0 0 0 1 
1 0 0 2 2 0 1 
1 0 0 2 0 0 1 
1 1 1 2 0 0 1 
1 2 2 2 0 0 1 
1 2 0 0 0 0 1 
1 1 1 1 1 1 1 

进程已结束，退出代码为 0
```

## 5、八皇后问题(回溯算法)

### ①、八皇后问题介绍

1. 八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。
2. 该问题是国际西洋棋棋手马克斯·贝瑟尔于 1848 年提出：
3. 在 8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法
4. 答案：92

### ②、算法思路分析和图解

1. 开始放置：从棋盘的第一行开始，尝试将第一个皇后放置在第一列。
2. 检查并放置下一个皇后：移动到下一行，尝试在第一列放置第二个皇后，并检查是否与前面的皇后冲突。如果冲突，尝试下一列，直到找到合适的位置。
3. 递归重复：对每一行重复第二步的过程。如果在当前行找不到任何合适的列来放置皇后，回退到上一行并移动皇后到下一个列。
4. 找到解决方案：如果能够为最后一行放置皇后且无冲突，那么这就是一个有效的解决方案。
5. 回溯查找所有解：找到一个解后，回退到上一个皇后，尝试将其移动到下一列，然后重复以上步骤来查找所有可能的解。
6. 说明：理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题：
7. 使用数组表示法：

```java
// 每个元素的索引代表行，值代表列
int[] arr = new int[8];
```

8. 如果数组如下配置，则表示：
	1. 第 1 个皇后在第 1 行第 1 列
	2. 第 2 个皇后在第 2 行第 5 列
	3. 第 3 个皇后在第 3 行第 8 列
	4. 此类推

```java
arr = {0, 4, 7, 5, 2, 6, 1, 3};
```

![|401](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240716150438.png)

### ③、算法代码实现

1. 实例代码

```java
package com.yuehai._05_recursion;

import java.util.Arrays;

/**
 * 八皇后问题
 * @author 月海
 * @date 2024/7/16 15:24
 * @description 八皇后问题
 * <p></p>
 * 问题描述：
 * 在 8x8 的国际象棋上摆放 8 个皇后，使其不能相互攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上。
 * 问有多少种摆法？
 */
public class EightQueensProblem {
    
    /**
     * 计数，当前是第几种摆法
     */
    private static int count = 0;
    
    /**
     * 表示皇后的个数，也表示行数
     */
    private static final int MAX = 8;
    
    public static void main(String[] args) {
        /*
            创建一个一维数组，下标表示行，值表示列
         */
        int[] array = new int[MAX];
        
        // 调用 check 方法，开始摆放皇后
        check(0, array);
    }
    
    /**
     * 摆放皇后
     * @param n 第 n 个皇后
     * @param array 一维数组，下标表示行，值表示列
     */
    public static void check(int n, int[] array) {
        // 如果 n 等于 8，表示 8 个皇后已经摆放完毕，输出结果，然后回溯，继续摆放
        if (n == MAX) {
            // 摆法加 1
            count++;
            System.out.println("摆放完毕，第 " + count + " 种摆法：" + Arrays.toString(array));
            return;
        }
        // 依次放入皇后，并判断是否冲突
        for (int i = 0; i < MAX; i++) {
            // 先把当前这个皇后 n 放到该行的第 1 列
            array[n] = i;
            // 判断当放置第 n 个皇后到 i 列时，是否冲突
            if (judge(n, array)) {
                // 不冲突，接着放 n+1 个皇后
                check(n + 1, array);
            }
            // 如果冲突，继续执行 array[n] = i，即将第 n 个皇后放置在本行的后移的一个位置
        }
    }
    
    /**
     * 查看当我们放置第 n 个皇后时，就去检测该皇后是否和前面已经摆放的皇后冲突
     * @param n 第 n 个皇后
     * @param array 一维数组，下标表示行，值表示列
     * @return 是否冲突，true 表示不冲突，false 表示冲突
     */
    public static boolean judge(int n, int[] array) {
        // 遍历判断前面的 n 个皇后是否和第 n 个皇后冲突；不在同一列和同一斜线
        for (int i = 0; i < n; i++) {
            /*
                array[i] == array[n]：判断第 n 个皇后是否和前面的 n-1 个皇后在同一列
                Math.abs(n - i) == Math.abs(array[n] - array[i])：判断第 n 个皇后是否和第 i 个皇后在同一斜线
             */
            if (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) {
                return false;
            }
        }
        return true;
    }
    
}
```

2. 结果：

```shell
摆放完毕，第 1 种摆法：[0, 4, 7, 5, 2, 6, 1, 3]
摆放完毕，第 2 种摆法：[0, 5, 7, 2, 6, 3, 1, 4]
摆放完毕，第 3 种摆法：[0, 6, 3, 5, 7, 1, 4, 2]
摆放完毕，第 4 种摆法：[0, 6, 4, 7, 1, 3, 5, 2]
摆放完毕，第 5 种摆法：[1, 3, 5, 7, 2, 0, 6, 4]
摆放完毕，第 6 种摆法：[1, 4, 6, 0, 2, 7, 5, 3]
摆放完毕，第 7 种摆法：[1, 4, 6, 3, 0, 7, 5, 2]
摆放完毕，第 8 种摆法：[1, 5, 0, 6, 3, 7, 2, 4]
摆放完毕，第 9 种摆法：[1, 5, 7, 2, 0, 3, 6, 4]
摆放完毕，第 10 种摆法：[1, 6, 2, 5, 7, 4, 0, 3]
摆放完毕，第 11 种摆法：[1, 6, 4, 7, 0, 3, 5, 2]
摆放完毕，第 12 种摆法：[1, 7, 5, 0, 2, 4, 6, 3]
摆放完毕，第 13 种摆法：[2, 0, 6, 4, 7, 1, 3, 5]
摆放完毕，第 14 种摆法：[2, 4, 1, 7, 0, 6, 3, 5]
摆放完毕，第 15 种摆法：[2, 4, 1, 7, 5, 3, 6, 0]
摆放完毕，第 16 种摆法：[2, 4, 6, 0, 3, 1, 7, 5]
摆放完毕，第 17 种摆法：[2, 4, 7, 3, 0, 6, 1, 5]
摆放完毕，第 18 种摆法：[2, 5, 1, 4, 7, 0, 6, 3]
摆放完毕，第 19 种摆法：[2, 5, 1, 6, 0, 3, 7, 4]
摆放完毕，第 20 种摆法：[2, 5, 1, 6, 4, 0, 7, 3]
摆放完毕，第 21 种摆法：[2, 5, 3, 0, 7, 4, 6, 1]
摆放完毕，第 22 种摆法：[2, 5, 3, 1, 7, 4, 6, 0]
摆放完毕，第 23 种摆法：[2, 5, 7, 0, 3, 6, 4, 1]
摆放完毕，第 24 种摆法：[2, 5, 7, 0, 4, 6, 1, 3]
摆放完毕，第 25 种摆法：[2, 5, 7, 1, 3, 0, 6, 4]
摆放完毕，第 26 种摆法：[2, 6, 1, 7, 4, 0, 3, 5]
摆放完毕，第 27 种摆法：[2, 6, 1, 7, 5, 3, 0, 4]
摆放完毕，第 28 种摆法：[2, 7, 3, 6, 0, 5, 1, 4]
摆放完毕，第 29 种摆法：[3, 0, 4, 7, 1, 6, 2, 5]
摆放完毕，第 30 种摆法：[3, 0, 4, 7, 5, 2, 6, 1]
摆放完毕，第 31 种摆法：[3, 1, 4, 7, 5, 0, 2, 6]
摆放完毕，第 32 种摆法：[3, 1, 6, 2, 5, 7, 0, 4]
摆放完毕，第 33 种摆法：[3, 1, 6, 2, 5, 7, 4, 0]
摆放完毕，第 34 种摆法：[3, 1, 6, 4, 0, 7, 5, 2]
摆放完毕，第 35 种摆法：[3, 1, 7, 4, 6, 0, 2, 5]
摆放完毕，第 36 种摆法：[3, 1, 7, 5, 0, 2, 4, 6]
摆放完毕，第 37 种摆法：[3, 5, 0, 4, 1, 7, 2, 6]
摆放完毕，第 38 种摆法：[3, 5, 7, 1, 6, 0, 2, 4]
摆放完毕，第 39 种摆法：[3, 5, 7, 2, 0, 6, 4, 1]
摆放完毕，第 40 种摆法：[3, 6, 0, 7, 4, 1, 5, 2]
摆放完毕，第 41 种摆法：[3, 6, 2, 7, 1, 4, 0, 5]
摆放完毕，第 42 种摆法：[3, 6, 4, 1, 5, 0, 2, 7]
摆放完毕，第 43 种摆法：[3, 6, 4, 2, 0, 5, 7, 1]
摆放完毕，第 44 种摆法：[3, 7, 0, 2, 5, 1, 6, 4]
摆放完毕，第 45 种摆法：[3, 7, 0, 4, 6, 1, 5, 2]
摆放完毕，第 46 种摆法：[3, 7, 4, 2, 0, 6, 1, 5]
摆放完毕，第 47 种摆法：[4, 0, 3, 5, 7, 1, 6, 2]
摆放完毕，第 48 种摆法：[4, 0, 7, 3, 1, 6, 2, 5]
摆放完毕，第 49 种摆法：[4, 0, 7, 5, 2, 6, 1, 3]
摆放完毕，第 50 种摆法：[4, 1, 3, 5, 7, 2, 0, 6]
摆放完毕，第 51 种摆法：[4, 1, 3, 6, 2, 7, 5, 0]
摆放完毕，第 52 种摆法：[4, 1, 5, 0, 6, 3, 7, 2]
摆放完毕，第 53 种摆法：[4, 1, 7, 0, 3, 6, 2, 5]
摆放完毕，第 54 种摆法：[4, 2, 0, 5, 7, 1, 3, 6]
摆放完毕，第 55 种摆法：[4, 2, 0, 6, 1, 7, 5, 3]
摆放完毕，第 56 种摆法：[4, 2, 7, 3, 6, 0, 5, 1]
摆放完毕，第 57 种摆法：[4, 6, 0, 2, 7, 5, 3, 1]
摆放完毕，第 58 种摆法：[4, 6, 0, 3, 1, 7, 5, 2]
摆放完毕，第 59 种摆法：[4, 6, 1, 3, 7, 0, 2, 5]
摆放完毕，第 60 种摆法：[4, 6, 1, 5, 2, 0, 3, 7]
摆放完毕，第 61 种摆法：[4, 6, 1, 5, 2, 0, 7, 3]
摆放完毕，第 62 种摆法：[4, 6, 3, 0, 2, 7, 5, 1]
摆放完毕，第 63 种摆法：[4, 7, 3, 0, 2, 5, 1, 6]
摆放完毕，第 64 种摆法：[4, 7, 3, 0, 6, 1, 5, 2]
摆放完毕，第 65 种摆法：[5, 0, 4, 1, 7, 2, 6, 3]
摆放完毕，第 66 种摆法：[5, 1, 6, 0, 2, 4, 7, 3]
摆放完毕，第 67 种摆法：[5, 1, 6, 0, 3, 7, 4, 2]
摆放完毕，第 68 种摆法：[5, 2, 0, 6, 4, 7, 1, 3]
摆放完毕，第 69 种摆法：[5, 2, 0, 7, 3, 1, 6, 4]
摆放完毕，第 70 种摆法：[5, 2, 0, 7, 4, 1, 3, 6]
摆放完毕，第 71 种摆法：[5, 2, 4, 6, 0, 3, 1, 7]
摆放完毕，第 72 种摆法：[5, 2, 4, 7, 0, 3, 1, 6]
摆放完毕，第 73 种摆法：[5, 2, 6, 1, 3, 7, 0, 4]
摆放完毕，第 74 种摆法：[5, 2, 6, 1, 7, 4, 0, 3]
摆放完毕，第 75 种摆法：[5, 2, 6, 3, 0, 7, 1, 4]
摆放完毕，第 76 种摆法：[5, 3, 0, 4, 7, 1, 6, 2]
摆放完毕，第 77 种摆法：[5, 3, 1, 7, 4, 6, 0, 2]
摆放完毕，第 78 种摆法：[5, 3, 6, 0, 2, 4, 1, 7]
摆放完毕，第 79 种摆法：[5, 3, 6, 0, 7, 1, 4, 2]
摆放完毕，第 80 种摆法：[5, 7, 1, 3, 0, 6, 4, 2]
摆放完毕，第 81 种摆法：[6, 0, 2, 7, 5, 3, 1, 4]
摆放完毕，第 82 种摆法：[6, 1, 3, 0, 7, 4, 2, 5]
摆放完毕，第 83 种摆法：[6, 1, 5, 2, 0, 3, 7, 4]
摆放完毕，第 84 种摆法：[6, 2, 0, 5, 7, 4, 1, 3]
摆放完毕，第 85 种摆法：[6, 2, 7, 1, 4, 0, 5, 3]
摆放完毕，第 86 种摆法：[6, 3, 1, 4, 7, 0, 2, 5]
摆放完毕，第 87 种摆法：[6, 3, 1, 7, 5, 0, 2, 4]
摆放完毕，第 88 种摆法：[6, 4, 2, 0, 5, 7, 1, 3]
摆放完毕，第 89 种摆法：[7, 1, 3, 0, 6, 4, 2, 5]
摆放完毕，第 90 种摆法：[7, 1, 4, 2, 0, 6, 3, 5]
摆放完毕，第 91 种摆法：[7, 2, 0, 5, 1, 4, 6, 3]
摆放完毕，第 92 种摆法：[7, 3, 0, 2, 5, 1, 6, 4]

进程已结束，退出代码为 0
```

# 六、排序算法

## 1、排序算法的介绍

1. 排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。
2. 排序的分类：
	1. 内部排序：指将需要处理的所有数据都加载到内部存储器中进行排序。
	2. 外部排序法：数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。
3. 常见的排序算法分类：

![](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2F常见的排序算法分类.png)

## 2、算法的时间复杂度

### ①、度量一个程序执行时间的两种方法

1. **事后统计的方法**：这种方法可行，但是有两个问题：
	1. 一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；
	2. 二是所得时间的统计量依赖于计算机的硬件、软件等环境因素，这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。
2. **事前估算的方法**：通过分析某个算法的时间复杂度来判断哪个算法更优

### ②、时间频度

#### Ⅰ、基本介绍

1. 一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。
2. 一个算法中的语句执行次数称为语句频度或时间频度。记为 `T(n)`

#### Ⅱ、举例说明：基本案例

1. 比如计算 1-100 所有数字之和, 我们设计两种算法：
2. 使用 for 循环：
	1. `T(n) = n + 1`
	2. 100 次循环 + 最后一次的 `i <= end` 判断

```java
int total = 0;
int end = 100;

for(int i = 1; i <= end; i++){
	total = total + 1;
}
```

3. 直接计算：
	1. `T(n) = 1`

```java
int total = 0;
int end = 100;

total = (1 + end) * end / 2
```

#### Ⅲ、举例说明：忽略常数项

1. 下面的表格，当 n = 300 时
	1. `T(n) = 2n + 20` 需要执行 620 次
	2. `T(n) = 2n` 需要执行 600 次
	3. `T(n) = 3n+10`  需要执行 910 次
	4. `T(n) = 3n`  需要执行 900 次

| n\T(n)  | `T(n) = 2n+20`   | `T(n) = 2n`  | `T(n) = 3n+10`   | `T(n) = 3n`  |
| ------- | -------------- | ----------- | -------------- | ----------- |
| **1**   | 22             | 2           | 13             | 3           |
| **2**   | 24             | 4           | 16             | 6           |
| **5**   | 30             | 10          | 25             | 15          |
| **8**   | 36             | 16          | 34             | 24          |
| **15**  | 50             | 30          | 55             | 45          |
| **30**  | 80             | 60          | 100            | 90          |
| **100** | 220            | 200         | 310            | 300         |
| **300** | 620            | 600         | 910            | 900         |

2. 结论：
	1. `2n+20` 和 `2n` 随着 n 变大，执行曲线无限接近，20 可以忽略
	2. `3n+10` 和 `3n` 随着 n 变大，执行曲线无限接近，10 可以忽略

![|480](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240717100339.png)

#### Ⅳ、举例说明：忽略低次项

| n\T(n)  | `T(2n^2+3n+10)` | `T(2n^2)` | `T(n^2+5n+20)` | `T(n^2)` |
| ------- | --------------- | --------- | -------------- | -------- |
| **1**   | 15              | 2         | 26             | 1        |
| **2**   | 24              | 8         | 34             | 4        |
| **5**   | 75              | 50        | 70             | 25       |
| **8**   | 162             | 128       | 124            | 64       |
| **15**  | 505             | 450       | 320            | 225      |
| **30**  | 1900            | 1800      | 1070           | 900      |
| **100** | 20310           | 20000     | 10520          | 10000    |

![|558](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240717103624.png)

1. `2n^2+3n+10` 和 `2n^2` 随着 n 变大，执行曲线无限接近，可以忽略 `3n+10`
2. `n^2+5n+20` 和 `n^2` 随着 n 变大，执行曲线无限接近, 可以忽略 `5n+20`

#### Ⅴ、举例说明：忽略系数

| n\T(n)  | `T(3n^2+2n)` | `T(5n^2+7n)` | `T(n^3+5n)` | `T(6n^3+4n)` |
| ------- | ------------ | ------------ | ----------- | ------------ |
| **1**   | 5            | 12           | 6           | 10           |
| **2**   | 16           | 34           | 18          | 56           |
| **5**   | 85           | 160          | 150         | 770          |
| **8**   | 208          | 376          | 552         | 3104         |
| **15**  | 705          | 1230         | 3450        | 20310        |
| **30**  | 2760         | 4710         | 27150       | 162120       |
| **100** | 30200        | 50700        | 1000500     | 6000400      |

![|578](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240717104321.png)

1. 随着 n 值变大，`5n^2+7n` 和 `3n^2+2n` ，执行曲线重合, 说明  这种情况下, 5 和 3 可以忽略。
2. 而 `n^3+5n` 和 `6n^3+4n`  ，执行曲线分离，说明多少次方式关键

### ③、时间复杂度

1. 一般情况下，算法中的基本操作语句的重复执行次数是问题规模 n 的某个函数，用 `T(n)` 表示
2. 若有某个辅助函数 `f(n)`，使得当 n 趋近于无穷大时，`T(n) / f(n)` 的极限值为不等于零的常数，则称 `f(n)` 是 `T(n)` 的同数量级函数。
3. 记作 `T(n) = O( f(n) )`，称 `O( f(n) )`  为算法的渐进时间复杂度，简称时间复杂度。
4. `T(n)` 不同，但时间复杂度可能相同。 如：`T(n) = n²+7n+6` 与 `T(n) = 3n²+2n+2` 它们的 `T(n)` 不同，但时间复杂度相同，都为 `O(n²)`。
5. 计算时间复杂度的方法：
	1. 用常数 1 代替运行时间中的所有加法常数 ：`T(n)=n²+7n+6` => `T(n)=n²+7n+1`
	2. 修改后的运行次数函数中，只保留最高阶项：`T(n)=n²+7n+1` => `T(n) = n²`
	3. 去除最高阶项的系数：`T(n) = n²` => `T(n) = n²` => `O(n²)`
 
### ④、常见的时间复杂度分别举例和分析

#### Ⅰ、常见的时间复杂度介绍

1. 常数阶：`O(1)`
2. 对数阶：O($\log_2 n$)
3. 线性阶：`O(n)`
4. 线性对数阶：O($n\log_2 n$)
5. 平方阶：O($n^2$)
6. 立方阶：O($n^3$)
7. k次方阶：O($n^k$)
8. 指数阶：O($2^n$)
9. 上面常见的算法时间复杂度为由小到大排列，随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低
10. 从图中可见，我们应该尽可能避免使用指数阶的算法

![](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240717135540.png)

#### Ⅱ、常数阶：`O(1)`

1. 无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是 `O(1)`

```java
int i = 1;
int j = 2;

++¡;
j++;

int m = i + j;
```

2. 上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用 `O(1)` 来表示它的时间复杂度。
3. 常数阶 `O(1)` 指的是算法的执行时间不随输入数据的大小变化而改变。即使输入数据的规模增大，执行时间仍保持不变。
4. 特点：
	1. 执行时间和输入数据的规模无关。
	2. 通常涉及到直接的操作，如基本赋值、基本运算、返回静态数据等。
5. 应用场景：
	1. 检索数组中的特定元素。
	2. 计算两个数的和或其他简单运算。

#### Ⅲ、对数阶：O($\log_2 n$)

```java
int i = 1;

while(i < n){
	i = i * 2;
}
```

1. 在 while 循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。
2. 假设循环 x 次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 $x = \log_2 n$，也就是说当循环 $x = \log_2 n$ 次以后，这个代码就结束了。
3. 因此这个代码的时间复杂度为：O($\log_2 n$) 
4. O($\log_2 n$) 的这个 2 时间上是根据代码变化的，i = i * 3 ，则是 O($\log_3 n$) 
5. 对数阶 O($\log_2 n$) 发生在算法分解问题大小的过程中，每次通过在问题规模上做除法来缩小问题的范围，常见于“分而治之”策略。
6. 特点：
	1. 每一步都减少一半的工作量。
	2. 常见于二分查找、某些分治算法等。
7. 应用场景：
	1. 二分查找在排序数组中查找元素。
	2. 一些高效的排序算法，如合并排序和快速排序的部分操作。
8. 对数介绍：对数公式是数学中的一种常见公式，如果 $a^x = N(a>0,且a≠1)$ ，则 x 叫做以 a 为底 N 的对数，记做 $x = \log_a N$，a 要写于 log 右下。其中 a 叫做对数的底，N 叫做真数。通常以 10 为底的对数叫做常用对数，以 e 为底的对数称为自然对数。

#### Ⅳ、线性阶：`O(n)`

```java
for(i = 1; i <= n; ++i) {
	j = i;
	j++;
}
```

1. 这段代码，for 循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的
2. 因此这类代码都可以用 `O(n)` 来表示它的时间复杂度
3. 线性阶 `O(n)` 指的是算法的执行时间与输入数据的大小成正比。
4. 特点：
	1. 执行时间随输入数据的大小线性增长。
	2. 处理每个数据元素恰好一次。
5. 应用场景：
	1. 遍历数组或列表。
	2. 简单搜索（未排序的数据）。

#### Ⅴ、线性对数阶：O($n\log_2 n$)

```java
for(m = 1; m < n; m++) {
	i = 1;
	while(i < n) {
		i = i * 2;
	}
}
```

1. 线性对数阶 O($n\log_2 n$) 其实非常容易理解，将时间复杂度为 O($\log_2 n$) 的代码循环 N 遍的话，那么它的时间复杂度就是 $n * O(\log_2 n)$，也就是 O($n\log_2 n$)
2. 线性对数阶 O($n\log_2 n$) 综合了线性增长和对数增长的特点，通常发生在处理每个数据元素需要对数时间的场景。
3. 特点：
	1. 比线性阶慢，比平方阶快。
	2. 常见于某些效率较高的排序算法。
4. 应用场景：快速排序和归并排序

#### Ⅵ、平方阶：O($n^2$)

```java
for(x = 1; i <= n; x++) {
	for(i = 1;i <= n;i++) {
		j = i;
		j++; 
	}
}
```

1. 平方阶 O($n^2$) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O($n^2$)
2. 这段代码其实就是嵌套了 2 层 n 循环，它的时间复杂度就是 O($n*n$)，即  O($n^2$)
3. 如果将其中一层循环的 n 改成 m，那它的时间复杂度就变成了 O($m*n$)
4. 平方阶 O($n^2$) 表示算法的执行时间是输入数据大小的平方。
5. 特点：
	1. 执行时间随输入数据的平方增长。
	2. 常见于简单排序算法（如冒泡排序）、双重循环。
6. 应用场景：
	1. 处理每对数据元素间的关系。
	2. 简单的数据排序算法。

#### Ⅶ、立方阶：O($n^3$)、k次方阶：O($n^k$)

1. 参考上面的 O($n^2$) ，O($n^3$) 相当于三层 n 循环
2. 立方阶 O($n^3$) 和 k 次方阶 O($n^k$) 是高度多项式的时间复杂度，表明执行时间与输入数据的三次方或更高次方成正比。
3. 特点：
	1. 执行时间极快速度增长。
	2. 通常用于处理三层以上的嵌套循环。
4. 应用场景：
	1. 多维数据分析。
	2. 某些图形和多体物理问题的算法。

#### Ⅷ、指数阶：O($2^n$)

```java
void recursiveFunction(int n) {
    if (n == 0) return;
    recursiveFunction(n - 1);
    recursiveFunction(n - 1);
}
```

1. 指数阶的时间复杂度表示为 O($2^n$)，是一种随着输入大小 n 增长而增长速度非常快的复杂度级别。
2. 在这种复杂度级别下，问题的解决方案可能涉及到对所有可能情况的枚举，每增加一个单位的输入大小，运算量几乎呈指数级增长。
3. 上面这段递归函数每次调用自身两次，除非达到递归的基条件（即 n 为 0）。因此，每一层的函数调用都会翻倍
4. 在递归的每一层，函数的调用次数都是前一层的两倍。从 1 开始，第一层有 1 次调用，第二层有 2 次调用，第三层有 4 次调用，以此类推，直到 n 层。
5. 递归深度为 n 时，总的调用次数是 $2^n - 1$（因为最底层调用到 0 时不再递归）。如果不考虑减去的 1，这就是典型的指数增长，即 O($2^n$)。
6. 时间复杂度影响：指数时间复杂度通常意味着算法的效率非常低，对于较大的输入值，这类算法可能非常慢，不适合实际应用。通常，我们会寻找替代的更高效算法，或者通过各种技术（如动态规划、分支限界等）来减少不必要的计算。
7. 适用场景：指数阶复杂度的算法通常出现在某些优化问题和搜索问题中，例如旅行商问题（TSP）、子集和问题等，这些问题没有已知的多项式时间算法解决方案

### ⑤、平均时间复杂度和最坏时间复杂度

1. **均时间复杂度**是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。
2. **最坏情况下的时间复杂度**称**最坏时间复杂度**。**一般讨论的时间复杂度均是最坏情况下的时间复杂度**。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。
3. 平均时间复杂度和最坏时间复杂度是否一致，和算法有关：

| 排序法 | 平均时间          | 最差情形           | 稳定度 | 额外空间     | 备注                  |
| --- | ------------- | -------------- | --- | -------- | ------------------- |
| 冒泡  | O($n^2$)      | O($n^2$)       | 稳定  | O(1)     | n 小时较好              |
| 交换  | O($n^2$)      | O($n^2$)       | 不稳定 | O(1)     | n 小时较好              |
| 选择  | O($n^2$)      | O($n^2$)       | 不稳定 | O(1)     | n 小时较好              |
| 插入  | O($n^2$)      | O($n^2$)       | 稳定  | O(1)     | 大部分已排序时较好           |
| 基数  | O($\log_R B$) | O($\log_R B$)  | 稳定  | O(n)     | B是真数（0-9），R是基数（个十百） |
| 希尔  | O($n\log_n$)  | O($n^s$) 1<s<2 | 不稳定 | O(1)     | s 是所选分组             |
| 快速  | O($n\log_n$)  | O($n^2$)       | 不稳定 | O(nlogn) | n 大时较好              |
| 归并  | O($n\log_n$)  | O($n\log_n$)   | 稳定  | O(n)     | n 大时较好              |
| 堆   | O($n\log_n$)  | O($n\log_n$)   | 不稳定 | O(1)     | n 大时较好              |

## 3、算法的空间复杂度简介

1. 类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模 n 的函数。
2. 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模 n 有关，它随着 n 的增大而增大，当 n 较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况
3. 在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间

## 4、冒泡排序

### ①、基本介绍

1. 冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。
2. 因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志 flag 判断元素是否进行过交换。从而减少不必要的比较。
3. 冒泡排序是一种简单的排序算法，它通过重复遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。这个过程重复进行，直到没有再需要交换的元素为止，这时数列已经排序完成。这个算法的名称由来是因为较小的元素会像“气泡”一样逐渐通过交换浮到数列的顶端

### ②、基本步骤

1. 比较相邻的元素：如果第一个比第二个大（假设排序的目标是从小到大），就交换它们两个。
2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后已经排好的元素。
4. 重复步骤2-3，直到排序完成

### ③、算法性能

1. **时间复杂度**：冒泡排序在最好情况下（即已经排序的数组）的时间复杂度为 O(n)，平均和最坏情况的时间复杂度都是 O($n^2$)
2. **空间复杂度**：冒泡排序是一个原地排序算法，除了用于交换的临时变量外，不需要额外的内存，所以它的空间复杂度为 O(1)

### ④、算法特点

1. **稳定性**：冒泡排序是一种稳定的排序算法，因为它不会改变相等元素的相对顺序。
2. **简单性**：冒泡排序是最简单易懂的排序算法之一，但这也导致了其效率问题，尤其是在数据规模较大时。
3. 尽管冒泡排序在实际应用中由于其低效率而不太受欢迎，但它仍然是教学和理解基本排序算法概念的一个很好的例子。在实践中，更高效的算法（如快速排序、归并排序等）通常是更好的选择，尤其是在处理大数据集时。

### ⑤、思路分析图

1. 例一：`79, 56, 90, 4, 32, 27, 16, 88, 35`

![](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240719125857.png)

2. 例二：原始数组：`3, 9, -1, 10, 20`：
3. 第一趟排序：
	1. 3, <font color="#00b0f0">9, -1</font>, 10, 20
	2. 3, -1, 9, 10, 20
	3. 3, -1, 9, 10, 20
	4. 3, -1, 9, 10, <font color="#ff0000">20</font>
4. 第二趟排序：
	1. <font color="#00b0f0">-1, 3</font>, 9, 10, <font color="#ff0000">20</font>
	2. -1, 3, 9, 10, <font color="#ff0000">20</font>
	3. -1, 3, 9, <font color="#ff0000">10, 20</font>
5. 第三趟排序：
	1. -1, 3, 9, <font color="#ff0000">10, 20</font>
	2. -1, 3, <font color="#ff0000">9, 10, 20</font>
6. 第四趟排序：
	1. -1, <font color="#ff0000">3, 9, 10, 20</font>
7. 一共进行**数组的大小 -1 次** 大的循环
8. 每一趟排序的次数在逐渐的减少
9. 如果我们发现在某趟排序中，一次交换也没有发生， 可以提前结束冒泡排序。这个就是优化

### ⑥、代码实现

1. 实例代码：

```java
package com.yuehai._06_SortingAlgorithm;

import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * 冒泡排序
 * @author 月海
 * @date 2024/7/19 12:55
 * @description 冒泡排序
 */
public class _04_BubbleSort {
    public static void main(String[] args) {
        // 定义一个数组，进行冒泡排序
        int[] arr = new int[80000];
        // 给数组赋值，随机生成 80000 个数
        for (int i = 0; i < 80000; i++) {
            arr[i] = (int) (Math.random() * 8000000);
        }
        
        // 获取排序前的时间
        long start = System.currentTimeMillis();
        // 进行冒泡排序
        bubbleSort(arr);
        // 获取排序后的时间
        long end = System.currentTimeMillis();
        
        // 输出排序所需的时间
        System.out.println("排序所需的时间为：" + (end - start) + "ms");
        // 每 50 个数为一行，打印排序后的数组
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
            if ((i + 1) % 50 == 0) {
                System.out.println();
            }
        }
    }
    
    /**
     * 冒泡排序
     * @param arr 待排序的数组
     */
    public static void bubbleSort(int[] arr) {
        // 临时变量
        int temp;
        // 标识变量，表示是否进行过交换
        boolean flag;
        
        // 外层循环，表示要进行多少轮排序
        for (int i = 0; i < arr.length - 1; i++) {
            // 重置标识变量
            flag = false;
            
            // 内层循环，表示每轮排序的次数
            for (int j = 0; j < arr.length - 1 - i; j++) {
                // 如果当前元素大于后一个元素，进行交换
                if (arr[j] > arr[j + 1]) {
                    // 交换
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    // 表示进行过交换
                    flag = true;
                }
            }
            
            // 如果没有进行过交换，说明已经是有序的，直接退出循环
            if (!flag) {
                break;
            }
        }
    }
}
```

2. 结果，取前 500 个数

```shell
排序所需的时间为：9140ms
23 194 243 288 297 583 651 687 757 850 1084 1179 1210 1372 1389 1402 1410 1449 1585 1797 2067 2144 2187 2238 2262 2583 2652 2988 3025 3036 3284 3382 3498 3676 3707 3718 3805 3864 3879 3917 3966 4024 4188 4208 4271 4547 4551 4786 4910 4933 
4941 4956 5236 5303 5396 5518 5681 5818 5923 5962 6024 6509 6602 6722 6726 6762 6950 7019 7058 7322 7378 7429 7816 7839 8002 8029 8058 8266 8450 8492 8533 8544 8706 8949 9099 9180 9523 9530 9534 9605 9631 9881 10233 10269 10440 10499 10569 10641 10689 10765 
10798 11111 11299 11364 11554 11633 11648 11653 11686 12107 12158 12308 12423 12427 12447 12461 12463 12509 12696 12788 13135 13382 13602 13837 13849 13932 14002 14038 14094 14196 14249 14394 14487 14564 14660 14661 14728 14753 14823 14953 15281 15545 15723 16079 16174 16209 16460 16536 16550 16647 
16654 16676 16809 16882 17184 17350 17514 17595 17604 17738 17751 17802 18072 18160 18201 18548 18627 18640 18658 18802 18814 18881 18915 18921 19038 19044 19061 19131 19131 19203 19289 19340 19350 19352 19479 19625 19829 19829 19927 19974 20063 20091 20250 20366 20466 20855 20970 21301 21530 21904 
21930 22090 22140 22394 22437 22442 22512 22646 22792 23223 23431 23465 23573 23734 23744 24175 24194 24236 24306 24506 24592 24646 24718 25033 25347 25429 25540 25557 25611 25725 25846 25971 25978 26076 26122 26154 26234 26443 26479 26646 26701 26799 26952 27079 27174 27249 27265 27276 27333 27396 
27789 27846 27896 27938 28013 28013 28024 28168 28287 28689 28700 28894 28916 28945 28952 29049 29137 29197 29213 29213 29305 29328 29398 29425 29480 29482 29582 29593 29637 29938 29947 30119 30182 30298 30370 30376 30537 30560 30572 30664 30666 30705 30797 30845 30948 31050 31096 31121 31170 31294 
31343 31465 31525 31660 31738 31995 31997 32015 32021 32046 32087 32151 32390 32832 32839 32893 32911 33080 33425 33500 33546 33784 33951 33975 34070 34181 34234 34325 34362 34363 34368 34494 34544 34549 34569 34685 34839 34863 34969 35052 35059 35207 35275 35306 35747 35750 35879 35888 36157 36266 
36364 36439 36759 36907 37415 37525 37684 37708 37910 37950 37976 38290 38773 38793 38866 38912 39034 39047 39281 39291 39313 39410 39412 39424 39511 39553 39664 39792 39818 39843 39974 40245 40487 40518 40518 40704 40714 40964 41067 41190 41219 41311 41357 41647 41655 41727 41749 41803 42300 42410 
42460 42514 42673 42769 42838 43078 43160 43466 43471 43534 44025 44103 44116 44180 44211 44379 44506 44839 44882 44933 44939 45213 45314 45339 45416 45443 45461 45537 45854 45883 45920 45971 45971 46173 46306 46380 46483 46859 46997 47265 47330 47407 47617 47642 47921 47947 48083 48112 48187 48231 
48373 48389 48442 48498 48510 48532 49179 49210 49374 49625 49633 49880 49958 50035 50294 50425 50435 50543 50710 50734 50741 50889 50911 50920 51046 51055 51197 51268 51448 51518 51547 51581 51795 51824 51914 51993 52048 52199 52418 52443 52488 52534 52735 52803 52805 52867 52968 53006 53027 53067 
```

## 5、选择排序

### ①、基本介绍

1. 选择式排序也属于内部排序法，是从预排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。
2. 选择排序是一种简单直观的比较排序算法。它的基本思想是在每次遍历中选择最小（或最大）的元素，然后将其放到数组的起始位置（或末尾位置），这个过程重复进行，直到整个数组排序完成

### ②、基本步骤

1. 开始时，整个数组是未排序的。
2. 第一轮选择，从所有未排序的元素中找到最小（或最大）的元素，将其与数组的第一个元素交换位置（如果第一个元素不是最小的话）。
3. 第二轮选择，从剩下的未排序的元素中找到最小的元素，将其与数组的第二个元素交换位置。
4. 重复过程，继续这个过程，每次跳过已经排序好的部分。
5. 结束，当只剩下最后一个元素时，整个数组已经排序完毕。

### ③、算法性能

1. **时间复杂度**：选择排序的平均和最坏情况时间复杂度都是 O($n^2$)，其中 n 是数组的长度。这是因为无论数组的初始状态如何，选择排序都会执行 n−1 轮比较，每轮比较的次数逐渐减少，从 n−1 到 1。
2. **空间复杂度**：选择排序是一种原地排序算法，它不需要额外的存储空间，所以其空间复杂度为 𝑂

### ④、算法特点

1. **不稳定的排序**：选择排序是不稳定的排序算法，因为在选择最小元素的过程中可能会破坏相同元素的初始顺序。
2. **简单且易于实现**：代码实现简单，适合于元素数量不是特别多的情况。
3. 尽管选择排序在理论上的效率不高，但它简单且不需要额外内存，这使得在内存资源受限的情况下或者元素数量较少时仍然有用。不过，对于大规模数据集，更高效的算法（如快速排序、归并排序等）通常是更好的选择。

### ⑤、思路分析图

1. 例一：

![](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240719151746.png)

2. 例二：
3. 原始的数组：101, 34, 119, 1
4. 第一轮排序：<font color="#ff0000">1</font>, 34, 119, 101
5. 第二轮排序：<font color="#ff0000">1, 34</font>, 119, 101
6. 第三轮排序：<font color="#ff0000">1, 34, 101</font>, 119
7. 说明：
	1. 选择排序一共有数组大小 - 1 轮排序
	2. 每 1 轮排序，又是一个循环，循环的规则
		1. 先假定当前这个数是最小数
		2. 然后和后面的每个数进行比较，如果发现有比当前数更小的数就重新确定最小数，并得到下标
		3. 当遍历到数组的最后时，就得到本轮最小数和下标
		4. 交换

### ⑥、代码实现

1. 代码实现，随机生成 80000 个数，然后进行排序，并记录时间

```java
package com.yuehai._06_SortingAlgorithm;

/**
 * 选择排序
 *
 * @author 月海
 * @date 2024/8/20 9:39
 * @description 选择排序
 */
public class _05_SelectionSort {
    public static void main(String[] args) {
        // 定义一个数组，进行选择排序
        int[] arr = new int[80000];
        // 给数组赋值，随机生成 80000 个数
        for (int i = 0; i < 80000; i++) {
            arr[i] = (int) (Math.random() * 8000000);
        }
        
        // 获取排序前的时间
        long start = System.currentTimeMillis();
        // 进行选择排序
        selectionSort(arr);
        // 获取排序后的时间
        long end = System.currentTimeMillis();
        
        // 输出排序所需的时间
        System.out.println("排序所需的时间为：" + (end - start) + "ms");
        // 每 50 个数为一行，打印排序后的数组
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
            if ((i + 1) % 50 == 0) {
                System.out.println();
            }
        }
    }
    
    /**
     * 选择排序
     *
     * @param arr 待排序的数组
     */
    public static void selectionSort(int[] arr) {
        // 临时变量
        int temp;
        // 最小值的索引
        int minIndex;
        
        /*
            外层循环，表示要进行多少轮排序
            i 的初始值为 0，表示第一轮排序，一开始指向第一个元素
            i 的最大值为 arr.length - 1，表示最后一轮排序，指向倒数第二个元素，因为最后一个元素不需要排序
         */
        for (int i = 0; i < arr.length - 1; i++) {
            // 每轮排序的第一个元素默认为最小值
            minIndex = i;
            
            /*
                内层循环，表示每轮排序的次数
                ii 的初始值为 i + 1，表示从第二个元素开始比较
                ii 的最大值为 arr.length，表示比较到最后一个元素
             */
            for (int ii = i + 1; ii < arr.length; ii++) {
                // 如果当前元素小于最小值，更新最小值的索引
                if (arr[ii] < arr[minIndex]) {
                    minIndex = ii;
                }
            }
            
            /*
                当循环结束后，找到最小值的索引
                如果最小值的索引不是当前元素的索引，进行交换
             */
            if (minIndex != i) {
                temp = arr[i];
                arr[i] = arr[minIndex];
                arr[minIndex] = temp;
            }
        }

    }
}
```

2. 结束输出，取前 500 个数：

```shell
排序所需的时间为：2478ms
2 95 592 653 686 797 819 861 861 923 995 997 1021 1255 1267 1371 1451 1546 1625 1659 1678 1797 1821 1888 1890 1999 2048 2132 2293 2310 2356 2404 2506 2522 2551 2557 2603 2694 2721 2961 2965 3338 3365 3424 3568 3596 3618 3652 3768 3909 
3988 4128 4347 4622 4689 4912 4943 5237 5293 5297 5322 5387 5496 5498 5589 5650 5860 5925 5931 6037 6228 6583 6666 6925 6925 6978 7022 7296 7305 7740 7772 7798 7837 7865 7959 8069 8298 8411 8645 8705 8719 8827 8836 8836 8892 8980 9007 9360 9395 9540 
9631 9695 9723 10058 10080 10120 10132 10205 10280 10405 10551 10694 10705 10833 10856 10868 10888 10912 11039 11067 11214 11302 11328 11416 11516 11675 11850 11975 11992 12152 12406 12427 12546 12890 12998 13071 13117 13148 13153 13177 13250 13269 13427 13604 13643 13785 13843 13970 14017 14100 
14254 14480 14520 14685 14879 15035 15592 15863 15975 16183 16248 16254 16268 16340 16513 16788 16849 16983 17084 17156 17218 17358 17423 17484 17664 18054 18479 18527 18575 18756 18838 18862 18873 18876 18917 19018 19261 19313 19318 19389 19440 19489 19556 19939 20069 20095 20114 20154 20380 20398 
20404 20465 20502 20516 20598 20786 20931 20955 21023 21224 21295 21374 21380 21496 21499 21607 21739 21943 21953 22017 22061 22188 22345 22353 22502 22612 22738 22784 22833 22843 22849 23071 23102 23115 23174 23205 23268 23323 23461 23486 23510 23534 23562 23588 23599 23615 23718 23753 23782 23801 
23921 23939 23953 24011 24083 24179 24277 24307 24347 24425 24608 24662 24675 24744 24941 25101 25266 25278 25373 25464 25471 25497 25506 25612 25734 25773 25773 25849 25902 25990 25991 26054 26088 26151 26434 26450 26496 26642 26729 27063 27065 27123 27210 27623 27706 27769 27779 27825 28131 28174 
28338 28361 28398 28418 28499 28550 28927 28982 29239 29352 29840 29907 29935 30076 30411 30420 30527 30592 30866 31075 31075 31107 31167 31260 31263 31531 31535 31710 31754 31809 31923 32055 32148 32207 32216 32261 32299 32873 33120 33126 33166 33316 33451 33572 33817 34204 34361 34472 34617 34681 
34690 34706 34868 34903 34905 35095 35178 35255 35320 35416 35458 35555 35563 35632 35768 35952 35976 36021 36186 36199 36220 36291 36310 36321 36355 36438 36527 36560 36580 36740 36753 36855 37057 37150 37168 37228 37260 37400 37505 37634 37641 37947 38016 38069 38105 38115 38351 38368 38673 38890 
39117 39207 39245 39260 39371 39373 39515 39579 39579 39671 39686 39747 39781 39915 39918 39959 39989 40064 40357 40423 40642 40730 40794 40815 40823 40931 40933 40938 41068 41127 41186 41209 41288 41550 41736 41738 41748 41776 41815 41941 42083 42234 42301 42540 42653 42743 42900 42961 42974 43082 
43147 43294 43515 43546 43651 43658 43670 43677 43910 44067 44090 44105 44231 44361 44439 44776 44786 44912 45029 45033 45164 45373 45456 45506 45724 45818 45868 45882 45896 46315 46342 46367 46432 46537 46565 46700 46709 46760 46819 46872 46967 47102 47244 47702 47746 47778 47827 47908 47948 47974 
```

## 6、插入排序

### ①、基本介绍

1. 插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的
2. 插入排序是一种简单直观的排序算法，非常适合小规模数据或几乎排序好的数据集。
3. 其核心思想是将数组分为已排序部分和未排序部分，逐个将未排序部分的元素正确插入到已排序部分
4. 插入排序的基本思想是：把 n 个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有 n-1 个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表

### ②、基本步骤

1. 开始时，将数组的第一个元素视为已排序的部分。
2. 第一轮插入，取出下一个元素（未排序部分的第一个元素），在已排序部分中从后向前扫描，找到适当的位置插入，并将插入点之后的元素都向后移动一位。
3. 重复过程，继续取出未排序部分的下一个元素，重复上述步骤，直到所有元素都被移动到正确的位置。
4. 结束，当所有元素都被视为已排序部分时，排序完成。

### ③、算法性能

1. **时间复杂度**：插入排序的平均和最坏情况时间复杂度均为 O($n^2$)，其中 n 是数组长度。这是因为每个新元素可能需要与所有已排序元素比较后才找到合适位置。最好情况的时间复杂度是 O(n)，适用于已经排序的数组。
2. **空间复杂度**：插入排序是一种原地排序算法，只需要一个额外的存储空间用于临时存放被插入的元素，因此空间复杂度为 O(1)

### ④、算法特点

1. 稳定性：插入排序是一种稳定的排序算法，因为它不会改变相同元素的初始相对顺序。
2. 适用场景：插入排序适用于数据量小或者大部分已经排好序的数组。在这些情况下，插入排序可以提供非常高效的排序性能。
3. 适应性：能够适应实时数据输入的情况，可以一边接收数据一边进行排序。
4. 尽管插入排序的最坏情况效率不是特别高，但其简单性和对小规模或基本有序的数据集中的高效表现使得它在实际应用中仍然非常有用。在实现方面，插入排序通常作为更复杂排序算法如希尔排序的基础部分使用。

### ⑤、思路分析图

![](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240820111823.png)

### ⑥、代码实现

1. 代码实现，随机生成 80000 个数，然后进行排序，并记录时间

```java
package com.yuehai._06_SortingAlgorithm;

/**
 * 插入排序
 *
 * @author 月海
 * @date 2024/8/20 11:20
 * @description 插入排序
 */
public class _06_InsertionSort {
    public static void main(String[] args) {
        // 定义一个数组，进行插入排序
        int[] arr = new int[80000];
        // 给数组赋值，随机生成 80000 个数
        for (int i = 0; i < 80000; i++) {
            arr[i] = (int) (Math.random() * 8000000);
        }

        // 获取排序前的时间
        long start = System.currentTimeMillis();
        // 进行插入排序
        insertionSort(arr);
        // 获取排序后的时间
        long end = System.currentTimeMillis();

        // 输出排序所需的时间
        System.out.println("排序所需的时间为：" + (end - start) + "ms");
        // 每 50 个数为一行，打印排序后的数组
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
            if ((i + 1) % 50 == 0) {
                System.out.println();
            }
        }
    }
    
    /**
     * 插入排序
     *
     * @param arr 待排序的数组
     */
    public static void insertionSort(int[] arr) {
        // 临时变量
        int temp;
        // 待插入的位置，也即用于和当前元素比较的元素的索引
        int insertIndex;
        
        /*
            外层循环，表示要进行多少轮排序
            i 的初始值为 1，表示第一轮排序，一开始指向第二个元素
            i 的最大值为 arr.length，表示最后一轮排序，指向最后一个元素
         */
        for (int i = 1; i < arr.length; i++) {
            // 临时变量赋值为当前元素
            temp = arr[i];
            // 待插入的位置赋值为当前元素的前一个位置，即已排序部分的最后一个元素，从后往前比较
            insertIndex = i - 1;
            
            /*
                内层循环，用来找到待插入的数应该插入的位置
                insertIndex >= 0 表示待插入的数的索引大于等于 0，即待插入的数的索引不越界
                temp < arr[insertIndex] 表示当当前元素小于待插入的元素时，继续往前找
             */
            while (insertIndex >= 0 && temp < arr[insertIndex]) {
                // 如果当前元素小于待插入位置的元素，则待插入的元素后移一位，用于给当前元素腾出位置
                arr[insertIndex + 1] = arr[insertIndex];
                // 待插入的位置前移一位，用于和当前元素比较；若是 < 0，则说明当前元素是最小的，不需要再比较，直接插入到第一个位置
                insertIndex--;
            }
            
            // 循环结束后，找到待插入的位置，将当前元素插入到待插入的位置；+ 1 是因为前面 insertIndex-- 了
            arr[insertIndex + 1] = temp;
        }
    }
}
```

2. 结束输出，取前 500 个数：

```shell
排序所需的时间为：516ms
23 136 615 668 727 811 849 915 916 942 946 961 1039 1191 1202 1315 1983 2076 2084 2149 2174 2362 2452 2483 2663 2728 2746 2939 3011 3016 3223 3317 3338 3364 3372 3372 3375 3426 3475 3598 3772 3922 4034 4121 4226 4404 4479 4564 4677 4758 
4787 4907 4966 4971 5146 5152 5210 5220 5529 5688 5845 5962 5968 5996 6123 6819 6822 6851 6875 6931 6945 7031 7111 7191 7209 7408 7541 7559 7588 7599 7644 7851 7854 7883 8036 8042 8049 8205 8222 8285 8285 8300 8331 8379 8543 8574 8761 8913 8956 9010 
9037 9301 9479 9494 9499 9590 10037 10073 10219 10389 10409 10462 10514 10733 10968 11246 11346 11587 11600 11764 11819 12195 12225 12274 12445 12490 12514 12625 12668 12935 12987 13004 13332 13373 13471 13699 13836 13836 13904 13983 13993 14181 14252 14268 14304 14382 14402 14464 14531 14536 
14552 14600 14620 14659 14710 14812 14813 14953 15084 15128 15224 15232 15350 15356 15660 15699 15759 15769 15849 15908 15918 16102 16378 16480 16645 16672 16761 16793 17007 17187 17302 17394 17661 17661 17919 17960 18107 18123 18249 18285 18693 18732 18884 18896 19043 19104 19127 19177 19193 19265 
19370 19471 19563 19710 19743 19769 19772 19782 19847 19923 19935 19939 20031 20104 20291 20350 20352 20357 20552 20641 20795 20871 21026 21294 21424 21647 21693 21882 21950 22024 22365 22525 22585 22655 22701 22825 23105 23130 23243 23342 23551 23704 23764 23988 24065 24143 24269 24488 24506 24548 
24552 24566 24568 24926 25036 25056 25208 25338 25401 25429 25692 25904 25943 25954 25996 26002 26225 26394 26568 26605 26896 27000 27071 27243 27454 27568 27653 28132 28167 28328 28343 28419 28518 28556 28562 28804 28832 28887 29058 29146 29216 29225 29295 29414 29589 29730 29802 29927 30115 30244 
30264 30415 30433 30494 30562 30563 30567 30662 30943 30991 31017 31152 31184 31533 31569 31605 31616 31640 31643 31646 31665 31677 31681 31684 31760 31782 31878 31983 32012 32097 32146 32187 32391 32547 32672 32673 33086 33213 33301 33329 33468 33523 33572 33604 33639 33678 33712 33829 33915 34079 
34088 34110 34254 34390 34466 34623 34742 34981 34997 35012 35069 35115 35146 35155 35193 35492 35578 35590 35677 35714 35756 35793 35797 35812 35832 35933 35996 36082 36247 36274 36383 36455 36735 36777 36826 36874 36894 36910 36912 36944 37377 37482 37497 37497 37699 37705 37715 37775 37905 37923 
37952 38348 38660 38771 38924 39044 39103 39117 39159 39280 39510 39511 39634 39730 39802 39813 39909 40011 40055 40182 40287 40463 40552 40593 40619 40770 40899 41001 41065 41324 41376 41392 41464 41513 41559 41573 41653 41744 41753 41770 41800 41914 42010 42016 42446 42466 42480 42727 42820 42914 
43125 43276 43316 43487 43575 43623 43763 43864 43919 43950 44045 44052 44103 44160 44381 44760 44872 45212 45296 45392 45463 45540 45773 45820 46057 46148 46159 46298 46363 46499 46761 46823 46954 46957 46958 46985 47097 47098 47167 47255 47485 47519 47521 47608 47664 47722 47736 47940 47980 47985 
```

## 7、希尔排序

### ①、简单插入排序可能存在的问题

1. 数组 `arr = {2, 3, 4, 5, 6, 1}` 这时需要插入的数 1(最小), 这样的过程是：

```shell
{2, 3, 4, 5, 6, 6}
{2, 3, 4, 5, 5, 6}
{2, 3, 4, 4, 5, 6}
{2, 3, 3, 4, 5, 6}
{2, 2, 3, 4, 5, 6}
{1, 2, 3, 4, 5, 6}
```

2. 结论: 当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响

### ②、基本介绍

1. 希尔排序（Shell Sort），也称为缩小增量排序，是由 Donald Shell 于 1959 年提出的一种排序算法。
2. 希尔排序是插入排序的一种更高效的改进版本，其核心思想是先将整个待排序的记录序列分割成为若干个子序列分别进行直接插入排序，待整个序列中的记录**基本有序**时，再对全体记录进行一次直接插入排序。

### ③、基本步骤

1. **选择一个增量序列** $t_1, t_2, \ldots, t_k$，其中每个增量满足 $t_i > t_{i+1}$，最后一个增量 $t_k = 1$（即最后一步是普通的插入排序）
2. **按增量进行排序**：对于每个增量 $t_i$，将序列分成长度为 $t_i$ 的若干子序列，分别对每个子序列进行直接插入排序。子序列的构成是：取序列中间隔 $t_i$ 的元素组成子序列
3. **减小增量重新排序**：完成上一步后，减小增量（例如选择下一个较小的增量），并重复第二步的子序列排序操作
4. **重复步骤 2 和 3**，直到最后一次执行普通的插入排序 $t_k = 1$

### ④、算法性能

1. **时间复杂度**：希尔排序的时间复杂度与增量序列的选择有关，最好情况可以达到 O($nlog_n$)，但最坏情况仍可能为 O($n^2$)。常见的增量序列如 Hibbard 的增量序列 $1, 3, 7, \ldots, 2^k-1$ 可以使希尔排序的时间复杂度降至大约 O($n^{3/2}$)
2. **空间复杂度**：希尔排序是原地排序算法，只需要固定的额外空间用于交换，所以其空间复杂度为 O(1)

### ⑤、算法特点

1. **非稳定性**：希尔排序是一种非稳定的排序算法，因为间隔较远的元素可以交换，可能会改变相等元素的初始相对顺序。
2. **适用场景**：希尔排序适用于中等大小的数组。它的复杂性低于简单的 O($n^2$) 算法（如插入排序和冒泡排序），特别是在数据项相对较大的序列中。
3. 希尔排序由于其较低的实现复杂性和中等的效率，在实际中有一定的应用场景，尤其是在数据量不是特别大，但希望效率高于简单插入排序时。

### ⑥、思路分析图

![](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240820150941.png)

### ⑦、代码实现

## 8、快速排序

### ①、基本介绍

1. 快速排序（Quicksort）是一种非常高效的排序算法，由托尼·霍尔在 1960 年提出。它使用分治法（Divide and Conquer）策略来递归地将数据分为两部分，每部分再继续进行排序，因此得名**快速排序**
2. 快速排序是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列

### ②、基本步骤

1. **选择基准值**（Pivot）：从数列中挑出一个元素，称为**基准**（Pivot）。
2. **分区操作**：重新排列数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（Partition）操作。
3. **递归排序**：递归地（Recursive）将小于基准值元素的子数列和大于基准值元素的子数列排序。

### ③、算法性能

1. **时间复杂度**：快速排序在最好的情况下和平均情况下的时间复杂度都为 O($nlog_n$)，但在最坏的情况下会退化到 O($n^2$)。最坏的情况发生在每次分区操作所选的基准都是最大或最小元素，导致每次只减少一个元素。
2. **空间复杂度**：快速排序的空间复杂度为 O($log_n$)，这是因为递归调用的栈空间。

### ④、算法特点

1. **非稳定性**：快速排序是一种非稳定的排序算法，因为分区过程中相等的元素可能会因为分区而改变相对位置。
2. **适用场景**：快速排序适用于大多数实际情况，尤其是大数据集，因为它的平均性能非常好。它不适用于数据集非常小或者基本有序的情况，这种情况下，插入排序可能更优。
3. 快速排序的关键在于基准的选择，一个好的基准可以极大地提升排序效率。实际应用中常用策略是随机选择基准，或者选择中位数作为基准，以避免最坏的性能。此外，快速排序因其优异的平均性能和 O($log_n$) 的额外空间消耗而广泛用于各种场景中。

### ⑤、思路分析图

![](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240821105605.png)

### ⑥、代码实现

## 9、归并排序

### ①、基本介绍

1. 归并排序是一种高效的排序算法，基于分治法（Divide and Conquer）的原理工作。这种算法由 John von Neumann 于 1945 年提出，其主要优点是稳定性高和同样优秀的性能表现于各类数据上
2. 归并排序（MERGE-SORT）是利用**归并**的思想实现的排序方法，该算法采用经典的**分治**（divide-and-conquer）策略
	1. 分治法将问题**分**（divide）成一些小的问题然后递归求解
	2. 而**治**（conquer）的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)

### ②、基本步骤

1. **分解**：将原始数组分解成若干子数组，直到每个子数组只有一个元素或为空，这样的数组自然是有序的。
2. **合并**：逐层合并子数组，保证每次合并后的新数组也是有序的。合并过程需要额外的空间来临时存放数据

### ③、详细步骤

1. **递归地分解数组**：如果数组长度大于 1，则将数组从中间分成左右两部分，分别对左右两部分递归进行归并排序。
2. **合并有序数组**：将两个有序的子数组合并成一个有序数组。合并过程中，从两个数组的开头取元素进行比较，将较小的元素放入结果数组，直到一个数组为空，然后将另一个数组的剩余部分复制到结果数组中。

### ④、算法性能

1. - **时间复杂度**：归并排序在所有情况下的时间复杂度均为 O($nlog_n$)，其中 n 是数组的长度。这是因为每一层合并操作近似需要 O(n) 的时间，而分解和合并的层数是 $log_n$
2. **空间复杂度**：归并排序需要与原数组相等的存储空间来存放临时数组，因此空间复杂度为 O(n)

### ⑤、算法特点

1. **稳定性**：归并排序是一种稳定的排序算法，即相同的元素在排序前后会保持原有的相对顺序。
2. **适用场景**：归并排序非常适合处理大数据量的排序，尤其是在数据不能一次性装入内存时，它能有效地进行外部排序。此外，归并排序广泛应用于数据重构和管理系统。
3. 归并排序因其稳定的排序性能和对大规模数据处理的能力而被广泛使用，尤其在需要稳定排序的场合下，如数据库中记录的排序和文件的整理。

### ⑥、思路分析图

#### Ⅰ、归并排序思想示意图1：基本思想

1. 可以看到这种结构很像一棵完全二叉树
2. 这次的归并排序采用递归去实现（也可采用迭代的方式去实现）
3. 分阶段可以理解为就是递归拆分子序列的过程。

![|700](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240821110627.png)

#### Ⅱ、归并排序思想示意图2：合并相邻有序子序列

1. 再来看看治阶段，需要将两个已经有序的子序列合并成一个有序序列
2. 比如上图中的最后一次合并，要将 `[4,5,7,8]` 和 `[1,2,3,6]` 两个已经有序的子序列，合并为最终序列 `[1,2,3,4,5,6,7,8]`
3. 来看下实现步骤：

![](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240821110823.png)

![](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240821110830.png)

### ⑦、代码实现

## 10、基数排序(桶排序)

### ①、基本介绍

1. 基数排序（radix sort）属于**分配式排序**（distribution sort），又称桶子法（bucket sort）或 bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些**桶**中，达到排序的作用
2. 基数排序是 1887 年赫尔曼·何乐礼发明的，是桶排序的扩展
3. 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割或展开，然后按每个位数进行排序。这种方法通常用于大量数据的排序，尤其是当键值的范围不是特别大时。基数排序可以使用两种方法：最高有效位（MSD）排序或最低有效位（LSD）排序

### ②、插入排序的步骤

1. 数据准备和分配方式：
	1. **最低有效位（LSD）**：从最低位开始，逐步对每个位执行排序过程，常用于整数和字符串排序
	2. **最高有效位（MSD）**：从最高位开始进行排序，常用于字符串和变长数据的排序
2. 排序过程：
	1. 准备相同数量的桶（通常是 10 个，对应 0 到 9 的数字）
	2. 根据当前处理的位（数字或字符），将所有元素分配到对应的桶中
	3. 按桶的顺序收集元素，准备下一位的排序
	4. 重复上述过程，直到最高位

### ③、算法性能

1. **时间复杂度**：基数排序的时间复杂度为 O($w \cdot n$)，其中 w 是数值中的最大位数，n 是元素数量。因此，当 w 相对较小且固定时，基数排序的性能可以非常高效
2. **空间复杂度**：基数排序需要额外的空间来存放临时的桶和数据，这通常是 O($n + k$)，其中 k 是基数，对于十进制数，k 为 10

### ④、算法特点

1. **稳定性**：基数排序是稳定的，这意味着两个具有相同键值的元素在排序后将保持其原始相对位置。
2. **适用场景**：基数排序非常适合于那些键值范围不大的场景，如电话号码、整数和短字符串等。它也特别适用于可以确定最大位数的数据。
3. 基数排序的效率与数据的特性有很大关系。对于键值较小且分布均匀的数据集，基数排序可以提供非常高的效率。然而，对于键值范围极大或者数据分布不均的情况，基数排序的性能可能不如比较型排序算法，如快速排序或归并排序。此外，基数排序对内存的要求较高，因为需要额外的存储空间来构建桶。

### ⑤、思路分析图

- 将数组 {53, 3, 542, 748, 14, 214} 使用基数排序, 进行升序排序

#### Ⅰ、第 1 轮排序：按照个位排序

1. 说明： 事先准备 10 个数组(10 个桶)， 0-9 分别对应位数的 0-9
2. 将各个数，按照个位大小放入到对应的各个数组中 
3. 然后从 0-9 个数组/桶，依次，按照加入元素的先后顺序取出
4. 第1轮排序后：`542 53 3 14 214 748` 

![|700](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240821112116.png)

#### Ⅱ、第2轮排序：按照十位排序

1. 将各个数，按照十位大小放入到对应的各个数组中
2. 然后从 0-9 个数组/桶，依次，按照加入元素的先后顺序取出
3. 第1轮排序后：`542 53 3 14 214 748`
4. 第2轮排序后： `3 14 214 542 748 53`

![|700](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240821112234.png)

#### Ⅲ、第3轮排序：按照百位排序

1. 将各个数，按照百位大小放入到对应的各个数组中 
2. 然后从 0-9 个数组/桶，依次，按照加入元素的先后顺序取出
3. 第 1 轮排序后：`542 53 3 14 214 748`
4. 第 2 轮排序后： `3 14 214 542 748 53`
5. 第 3 轮排序后：`3 14 53 214 542 748`
6. 排序完毕

![|700](https://www.yue-hai.top:10300/file/downloadFile?basePathType=takeDown&subPath=%2Fjava%2Fattachments%2FPasted%20image%2020240821112347.png)

### ⑥、代码实现

## 11、常用排序算法总结和对比




# 七、查找算法

查找算法介绍

线性查找算法

1)基本介绍
2)算法分析图解
3)代码实现线性查找算法

二分查找算法

1)基本介绍
2)算法分析图解
3)代码实现二分查找算法

插值查找算法

1)基本介绍
2)算法分析图解
3)代码实现插值查找算法

斐波那契(黄金分割法)查找算法

1)基本介绍
2)算法分析图解
3)代码实现斐波那契(黄金分割法)查找算法

# 八、哈希表

哈希表的基本原理

哈希表(散列)-Google上机题
自己动手写一个哈希表【数组+链表】(如：上图)
    1) 哈希表创建
    2) 哈希表的添加
    3) 哈希表的查找

# 九、树结构基础部分
二叉树
    1) 为什么需要树这种数据结构-非线性结构
    2) 二叉树示意图
    3) 二叉树的概念
    4) 二叉树遍历的说明
    5) 二叉树遍历应用实例(前序,中序,后序)
    6) 二叉树-查找指定节点
    7) 二叉树-删除节点

顺序存储二叉树
    1) 顺序存储二叉树的概念和特点
    2) 顺序存储二叉树遍历


线索化二叉树

    1) 先看一个实际问题-引入线索化二叉树
    2) 线索二叉树基本介绍
    3) 线索二叉树分析图解
    4) 线索二叉树代码实现
    5) 遍历线索化二叉树

# 十、树结构实际应用
堆排序

    1) 堆排序基本介绍
    2) 堆排序基本思想
    3) 堆排序步骤图解说明
    4) 堆排序代码实现


赫夫曼树

    1) 基本介绍
    2) 赫夫曼树几个重要概念和举例说明
    3) 赫夫曼树的代码实现
    4) 赫夫曼树的代码实现


赫夫曼编码

    1) 基本介绍
    2) 原理剖析及其图解
    3) 最佳实践-数据压缩(创建赫夫曼树)
    4) 最佳实践-数据压缩(生成赫夫曼编码和赫夫曼编码后的数据)
    5) 最佳实践-数据解压(使用赫夫曼编码解码)
    6) 最佳实践-文件压缩
    7) 最佳实践-文件解压(文件恢复)
    8) 赫夫曼编码压缩文件注意事项

二叉排序树

    1) 先看一个需求引出二叉排序树
    2) 解决方案分析
    3) 二叉排序树介绍
    4) 二叉排序树创建和遍历
    5) 二叉排序树的删除

平衡二叉树(AVL树)

    1) 看一个案例(说明二叉排序树可能的问题)
    2) 基本介绍
    3) 应用案例-单旋转(左旋转)
    4) 应用案例-单旋转(右旋转)
    5) 应用案例-双旋转

# 十一、多路查找树
二叉树与B树

    1) 二叉树的问题分析
    2) 多叉树
    3) B树的基本介绍
    4) 

2-3树

    1) 2-3树基本介绍
    2) 2-3树应用案例
    3) 2-3树其它说明


B树、B+树和B*树
    1) B树的介绍
    2) B树的运行原理

    3) B+树的介绍和原理

    4) B*树的介绍和原理

# 十二、图
图基本介绍
图的常用概念
图的快速入门案例
图的深度优先搜索算法介绍
图的创建和深度优先搜索算法
图的创建和深度优先搜索算法

# 十三、其他

# 十四、二分查找算法(非递归)

    1) 二分查找算法(非递归)介绍
    2) 二分查找算法(非递归)分析图解
    3) 二分查找算法(非递归)代码实现

# 十五、分治算法

    1) 分治算法介绍
    2) 分治算法的基本步骤
    3) 分治(Divide-and-Conquer(P))算法设计模式
    4) 分治算法最佳实践-汉诺塔实现

# 十六、动态规划算法

    1) 应用场景-背包问题

    2) 动态规划算法介绍
    3) 动态规划算法最佳实践-背包问题分析和实现

# 十七、KMP算法

    1) 应用场景-字符串匹配问题
    2) 暴力匹配算法
    3) KMP算法介绍
    4) 搜索词和部分匹配值

    5) KMP算法最佳应用-字符串匹配问题分析和实现

# 十八、贪心算法

    1) 应用场景-集合覆盖问题

    2) 贪心算法介绍
    3) 贪心算法最佳应用-集合覆盖的分析和实现
    4) 贪心算法注意事项和细节

# 十九、普里姆算法

    1) 应用场景-修路问题

    2) 最小生成树(Minimum Cost Spanning Tree)
    3) 极小连通子图
    4) 普里姆算法介绍
    5) 普里姆算法最佳实践(修路问题)分析和实现

# 二十、克鲁斯卡尔算法
    1) 应用场景-公交站问题

    2) 克鲁斯卡尔(Kruskal)算法介绍
    3) 加权连通图的最小生成树的算法
    4) 克鲁斯卡尔算法图解说明

    5) 克鲁斯卡尔算法代码实现

# 二十一、迪杰斯特拉算法

    1) 应用场景-最短路径问题
    2) 迪杰斯特拉(Dijkstra)算法介绍
    3) 广度优先搜索思想
    4) 迪杰斯特拉(Dijkstra)算法过程
    5) 迪杰斯特拉(Dijkstra)算法最佳应用-最短路径分析和实现

# 二十二、弗洛伊德算法

    1) 弗洛伊德(Floyd)算法介绍
    2) 弗洛伊德算法 VS 迪杰斯特拉算法
    3) 弗洛伊德(Floyd)算法图解分析

    4) 弗洛伊德(Floyd)算法最佳应用-最短路径分析和实现

# 二十三、马踏棋盘算法

    1) 马踏棋盘算法介绍和游戏演示

    2) 马踏棋盘游戏分析和代码实现
    3) 简单回溯法解决马踏棋盘的问题

    4) 深度优先搜索+贪心算法优化

# 二十四、

# 二十五、

# 二十六、

# 二十七、

### ①、基本介绍

### ②、插入排序的步骤

### ③、算法性能

### ④、算法特点

### ⑤、思路分析图

### ⑥、代码实现

## 1、

## 2、

## 3、

## 4、

## 5、

## 6、

## 7、

## 8、

## 9、

---

### ①、

### ②、

### ③、

### ④、

### ⑤、

### ⑥、

### ⑦、

### ⑧、

### ⑨、

### ⑩、

### ⑪、⑫、⑬、⑭、⑮、⑯、⑰、⑱、⑲、⑳

### ㉑、㉒、㉓、㉔、㉕、㉖、㉗、㉘、㉙、㉚

### ㉛、㉜、㉝、㉞、㉟、㊱、㊲、㊳、㊴、㊵

### ㊶、㊷、㊸、㊹、㊺、㊻、㊼、㊽、㊾、㊿

#### Ⅰ、

#### Ⅱ、

#### Ⅲ、

#### Ⅳ、

#### Ⅴ、

#### Ⅵ、

#### Ⅶ、

#### Ⅷ、

#### Ⅸ、

#### Ⅹ、

1. 
2. 
3. 
4. 
5. 
6. 
7. 
8. 
9. 
10. 
11. 
12. 
13. 
14. 
15. 
16. 
17. 
18. 
19. 
20. 
21. 














