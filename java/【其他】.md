# 一、基础知识

## 1、对象模型

### ①、常见的对象模型

#### Ⅰ、PO 持久化对象（Persistent Object）

1. PO 是持久化对象，用于表示数据库中的实体或表的映射
2. 通常与数据库表的结构和字段对应
3. PO 的属性对应数据库表的字段，可以进行持久化操作（新增、查询、更新、删除）
4. 例如：UserPO 中的属性和数据库表中的字段是一一对应的。

```java
// 通常与数据库表对应
public class UserPO {
    private Long id;
    private String username;
    private String password;
}
```

#### Ⅱ、VO 值对象（Value Object）

1. VO 是值对象，用于封装数据
2. 通常是不可变的，用于传递数据而不包含业务逻辑
3. VO 可以用于在不同层之间传递数据，如前端和后端之间，后端的返回的到前端的数据只需要保留必要的字段就可以，将这些必要的字段封装起来就是 VO
4. 例如：

```java
// 用于展示，例如给前端的用户视图
public class UserVO {
    private String username;
    private String display_name;
}
```

#### Ⅲ、BO 业务对象（Business Object）

1. BO 是业务对象，用于封装业务逻辑和操作
2. 包含与业务相关的方法和属性，用于实现业务规则和操作
3. BO 通常与领域模型紧密相关，用于表示业务概念和业务流程
4. 例如：UserBO 在包含了属性 id 和 username 的基础上还包含了对 username 的验证逻辑

```java
// 包含业务逻辑
public class UserBO {
    private Long id;
    private String username;
    
    public boolean isValid() {
        return username != null && !username.isEmpty();
    }
}
```

#### Ⅳ、DO 数据对象（Data/Domain Object）

1. DO 通常与 BO 和 PO 相对应，用于实现领域模型和业务逻辑，用于表示从数据存储中得到的数据
2. 例如：

```java
// 这里的 DO 和 PO 非常相似
public class UserDO {
    private Long id;
    private String username;
    private String password;
}
```

#### Ⅴ、TO 传输对象（Transfer Object）

1. TO 是传输对象（Transfer Object），用于在不同层或应用之间传输数据。
2. 轻量、简洁，用于封装数据，不包含业务逻辑。
3. 用于跨网络或层间传输数据，例如远程方法调用时，或者从服务层向外传递组合数据。

```java
public class UserTO {
    private String username;
    private String email;
}
```

#### Ⅵ、DTO 数据传输对象（Data Transfer Object）

1. DTO 是数据传输对象，用于在不同层之间传输数据
2. 通常用于优化数据传输的性能和减少网络通信的开销。
3. DTO 可以封装多个对象的数据，以减少网络请求次数
4. 如果说 VO 一般用于前端和后端之后传输数据，那么 DTO 就是在后端的不同层之间传递数据，例如 controller 层和 service 层或者在服务之间结构调用的时候使用 DTO
5. 例如：

```java
// 用于 API 或远程服务间的数据传输
public class UserDTO {
    private String username;
    private String email;
}
```

#### Ⅶ、DAO 数据访问对象（Data Access Object）

1. DAO 是数据访问对象，用于封装对数据库的访问操作，也就是我们常说的 Dao 层
2. 提供对数据库的增删改查等操作的接口
3. DAO 可以隐藏底层数据库的具体实现细节，使得业务逻辑层与数据库解耦
4. 例如：UserDao 提供了对数据库表 user 的增删改查操作，这里的 UserPO 就是我们上面说的用来一一对应接收表中的字段

```java
public interface UserDao {
    UserPO getById(Long id);
    void save(UserPO user);
    void delete(UserPO user);
    List<UserPO> findAll();
}
```

#### Ⅷ、POJO 普通Java对象（Plain Old Java Object）

1. POJO 是一个简单的 Java 对象，没有特定的限制和约束
2. 是一种普通的 Java 类，不依赖于特定的框架或接口
3. 例如：User 类是一个普通的 java 实体类

```java
// 简单的 Java 对象，不继承或实现任何特殊的类或接口
public class User {
    private Long id;
    private String name;
}
```

### ②、大致的示例代码

1. Controller 层：此层常见的转换为：DTO 转 VO
	1. Query：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类来传输。

```java
public List<UserVO> getUsers(UserQuery userQuery)
```

2. Service/Manager层：在 Service 内部使用 UserBO 封装中间所需的逻辑对象，此层常见的转换为：PO 转 DTO，或 PO 转 BO 转 DTO

```java
List<UserDTO> getUsers(UserQuery userQuery)
```

3. DAO层：

```java
List<UserPO> getUsers(UserQuery userQuery)
```

4. 图片示例：

![|725](https://www.yue-hai.top:10300/file/downloadFile?fullFilePath=%2Fhome%2Fyan%2F%E6%A1%8C%E9%9D%A2%2F%E5%86%85%E5%AD%98%2F%E6%96%87%E6%A1%A3%E8%B5%84%E6%96%99%2FTakeDown%2Fjava%2Fattachments%2FPasted%20image%2020240506134449.png)

### ③、区别与应用

#### Ⅰ、VO 和 DTO 的区别

1. 大家可能会有个疑问：既然 DTO 是展示层与服务层之间传递数据的对象，为什么还需要一个 VO 呢？对！对于绝大部分的应用场景来说，DTO 和 VO 的属性值基本是一致的，而且他们通常都是 POJO，因此没必要多此一举，但不要忘记这是实现层面的思维，对于设计层面来说，概念上还是应该存在 VO 和 DTO，因为两者有着本质的区别，DTO 代表服务层需要接收的数据和返回的数据，而VO代表展示层需要显示的数据。
2. 用一个例子来说明可能会比较容易理解：例如服务层有一个 getUser 的方法返回一个系统用户，其中有一个属性是 gender(性别)，对于服务层来说，它只从语义上定义：`1-男性，2-女性，0-未指定`，而对于展示层来说，它可能需要用“帅哥”代表男性，用“美女”代表女性，用“秘密”代表未指定。
3. 说到这里，可能你还会反驳，在服务层直接就返回“帅哥美女”不就行了吗？对于大部分应用来说，这不是问题，但设想一下，如果需求允许客户可以定制风格，而不同风格对于“性别”的表现方式不一样，又或者这个服务同时供多个客户端使用（不同门户），而不同的客户端对于表现层的要求有所不同，那么，问题就来了。再者，回到设计层面上分析，从职责单一原则来看，服务层只负责业务，与具体的表现形式无关，因此，它返回的 DTO，不应该出现与表现形式的耦合。
4. 理论归理论，这到底还是分析设计层面的思维，是否在实现层面必须这样做呢？一刀切的做法往往会得不偿失，下面马上会分析应用中如何做出正确的选择。

#### Ⅱ、VO 和 DTO 的应用

1. 上面只是用了一个简单的例子来说明 VO 与 DTO 在概念上的区别，这里将会说名如何在应用中做出正确的选择。
2. 在以下才场景中，我们可以考虑把 VO 与 DTO 二合为一（注意：是实现层面）：
	1. 当需求非常清晰稳定，而且客户端很明确只有一个的时候，没有必要把 VO 和 DTO 区分开来，这时候 VO 可以退隐，用一个 DTO 即可
	2. 为什么是 VO 退隐而不是 DTO？回到设计层面，服务层的职责依然不应该与展示层耦合，所以，对于前面的例子，很容易理解，DTO 对于“性别”来说，依然不能用“帅哥美女”，这个转换应该依赖于页面的脚本（如 JavaScript）或其他机制（JSTL、EL、CSS）
	3. 即使客户端可以进行定制，或者存在多个不同的客户端，如果客户端能够用某种技术（脚本或其他机制）实现转换，同样可以让 VO 退隐
3. 以下场景需要优先考虑VO、DTO并存：
	1. 上述场景的反面场景
	2. 因为某种技术原因，比如某个框架（如 Flex）提供自动把 POJO 转换为 UI 中某些 Field 时，可以考虑在实现层面定义出 VO，这个权衡完全取决于使用框架的自动转换能力带来的开发和维护效率提升与设计多一个 VO 所多做的事情带来的开发和维护效率的下降之间的比对。
	3. 如果页面出现一个“大视图”，而组成这个大视图的所有数据需要调用多个服务，返回多个 DTO 来组装（当然，这同样可以通过服务层提供一次性返回一个大视图的 DTO 来取代，但在服务层提供一个这样的方法是否合适，需要在设计层面进行权衡）。

#### Ⅲ、BO 和 DTO 的区别

1. 这两个的区别主要是就是字段的删减。
2. BO 对内，为了进行业务计算需要辅助数据，或者是一个业务有多个对外的接口，BO 可能会含有很多接口对外所不需要的数据，因此 DTO 需要在 BO 的基础上，只要自己需要的数据，然后对外提供。
3. 在这个关系上，通常不会有数据内容的变化，内容变化要么在 BO 内部业务计算的时候完成，要么在解释 VO 的时候完成。

### ④、相关的代码规范

#### Ⅰ、命名风格

1. 【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：`DO / BO /DTO / VO / AO` 
2. 正例：`MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion` 
3. 反例：`macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion`
4. 【参考】各层命名规约：
	1. `Service/DAO` 层方法命名规约
		1. 获取单个对象的方法用 `get` 做前缀。
		2. 获取多个对象的方法用 `list` 做前缀。
		3. 获取统计值的方法用 `count` 做前缀。
		4. 插入的方法用 `save/insert` 做前缀。
		5. 删除的方法用 `remove/delete` 做前缀。
		6. 修改的方法用 `update` 做前缀。
	2. 领域模型命名规约
		1. 数据对象：`xxxDO`，`xxx`` 即为数据表名。
		2. 数据传输对象：`xxxDTO`，xxx 为业务领域相关的名称。
		3. 展示对象：`xxxVO`，xxx 一般为网页名称。
		4. POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。

#### Ⅱ、OOP 规约

1. 【强制】定义 `DO/DTO/VO` 等 POJO 类时，不要设定任何属性默认值。
2. 反例：POJO 类的 addTime 默认值为 `new Date();` 但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。

### ⑤、我的理解

#### Ⅰ、po、vo、dto 的使用

1. `po` 和数据库对应，用来接收从数据库查询的数据，表示数据库表中的一行数据
	1. 主要用于 DAO 层和数据库之间的数据交换。
	2. 在业务层和展示层较少直接使用 PO，以避免暴露数据库的细节和结构
2. `vo` 用来给前端返回数据，根据展示逻辑定制的对象，可以只包含用户界面所需的数据
	1. 主要用在 Controller 层返回给前端，用于数据展示。
	2. 它可以从一个或多个 DTO、甚至 PO 中抽取和组合数据，生成适合前端显示的格式
3. `dto` 用于封装业务数据
	1. 主要在 Controller、Service 和 DAO 层之间传输数据。
	2. 可以从前端接收数据，传递给 Service 层处理，也可以从 Service 层获取数据，传递回 Controller 层向前端展示
4. 若是多表查询或对结果有筛选，可以使用 `dto`，然后使用如 MyBatis 的 `ResultMap` 将数据库查询的结果映射到 Java 对象的属性中：

#### Ⅱ、ResultMap 自动映射 dto

1. `UserDetailDTO` 类

```java
package com.example;

import lombok.Data;

@Data
public class UserDetailDTO {
    private Integer userId;
    private String userName;
    private String email;
    
    private Address address;
}
```

2. `Address` 类

```java
package com.example;

import lombok.Data;

@Data
public class Address {
    private String street;
    private String city;
    private String postalCode;
}
```

3. MyBatis 的映射文件中定义一个 ResultMap：

```xml
<resultMap id="userDetailMap" type="com.example.UserDetailDTO">
    <result column="user_id" property="userId" />
    <result column="user_name" property="userName" />
    <result column="email" property="email" />
    <association property="address" javaType="com.example.Address">
        <result column="street" property="street" />
        <result column="city" property="city" />
        <result column="postal_code" property="postalCode" />
    </association>
</resultMap>
```

4. 查询语句中使用 ResultMap

```xml
<select id="selectUserDetail" resultMap="userDetailMap">
    SELECT user_id, user_name, email, street, city, postal_code
    FROM users
    LEFT JOIN addresses ON users.address_id = addresses.id
    WHERE user_id = #{userId}
</select>
```

5. 在这个查询语句中：
	1. 使用 `resultMap="userDetailMap"` 来指定使用前面定义的 ResultMap。
	2. 查询从 users 表和 addresses 表中联合查询，使用 `LEFT JOIN` 来关联这两个表。
	3. 结果会被自动映射到 UserDetail 类的实例中，其中包含了 Address 类型的 address 属性。
	4. 通过这种方式，可以非常灵活地处理从数据库返回的数据，并且能够处理复杂的关联和嵌套数据结构。这在处理复杂业务模型时非常有用。

## 2、启动、停止、查看运行中的 java 程序

### ①、启动 Java 程序

```shell
java -jar yuehai-tool-1.0-SNAPSHOT-jar-with-dependencies.jar
```

### ②、在后台启动 Java 程序

1. `nohup` 命令用于运行一个命令，使得即使终端关闭，该命令也会继续执行。
2. `&` 符号将命令放到后台执行。

```shell
nohup java -jar yuehai-tool-1.0-SNAPSHOT-jar-with-dependencies.jar &
```

3. 还可以将日志输出到特定文件：
	1. `> yuehai-tool.log` 会将标准输出重定向到 `yuehai-tool.log` 文件
	2. `2>&1` 将错误输出重定向到标准输出（即同一个日志文件）。

```shell
nohup java -jar yuehai-tool-1.0-SNAPSHOT-jar-with-dependencies.jar > yuehai-tool.log 2>&1 &
```

### ③、停止 Java 程序

1. 使用 jps 或 ps 命令来找到 Java 进程的 PID：

```shell
jps -l

# 或者：

ps -ef | grep java
```

2. 一旦找到了进程的 PID，可以使用 kill 命令来停止它：

```shell
kill [PID]
```

3. 如果进程不响应普通的终止信号，可以发送更强制的信号：

```shell
kill -9 [PID]
```

4. 这将发送 SIGKILL 信号，立即终止进程。不过，尽量避免使用 -9 除非必要，因为它不给程序任何清理和保存工作的机会。

### ④、查看所有正在运行的 Java 程序

#### Ⅰ、 `ps` 命令

1. `ps` 命令是最常用的显示当前运行进程的工具之一。可以结合 `grep` 来过滤出 Java 进程：
2. 这条命令会列出系统中所有包含 "java" 关键字的进程。其中：
3. `ps` 表示 process status（进程状态）。
4. `-e` 参数显示所有进程。
5. `-f` 参数全格式显示，这将包括所有细节，如 PID、所属用户等。

```shell
ps -ef | grep java
```

#### Ⅱ、 `pgrep` 和 `ps` 结合


1. 使用 `pgrep` 和 `ps` 结合；`pgrep` 命令用于查找匹配特定条件的进程 ID，可以用它来找到所有 Java 进程的 PID，然后用 ps 获取更详细的信息：

```shell
pgrep -af java
```

2. 或者可以直接用 `ps` 和 `pgrep` 结合，来获取更详细的输出：
	1. 这里 `-x` 限制 `pgrep` 精确匹配 `java` 这个命令名。

```shell
ps -f $(pgrep -d, -x java)
```

#### Ⅲ、 `jps` 命令

1. 如果 JDK 安装在系统上，可以使用 `jps` 命令（Java Virtual Machine Process Status Tool）来列出所有 Java 进程。
2. `jps` 是专门为列出 JVM 进程而设计的，可以显示 Java 应用的本地或远程 JVM 实例
3. jps 显示 Java 进程：
	1. `-l` 参数显示 Java 进程的完整包路径。
	2. `jps` 提供的信息相对比较简单，通常只包括 PID 和 Java 程序的主类或 Jar 文件名。

```shell
jps -l
```

3. 如果需要更详细的信息（如参数等），可以使用 -v 选项：

```shell
jps -lv
```

#### Ⅳ、使用 `top` 或 `htop`

1. 如果想实时监控 Java 进程的资源使用情况，可以使用 `top` 或更高级的 `htop`（需要先安装 htop）：

```shell
top -c
```

2. 在 top 中，你可以使用按键过滤功能（按 o，然后输入 COMMAND=java）来只显示 Java 进程。

### ⑤、

## 3、

## 4、

## 5、


# 二、工具类

## 1、JSON 返回类

```java
package com.yuehai.redis_springboot_02.utils;

import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;

/**
 * @author 月海
 * @create 2022/9/20 15:20
 *
 * 使用 @RestController 或 @ResponseBody 时，可直接返回该对象，
 * Spring Boot 默认使用 Jackson 会自动将该对象转换为 json 字符串
 * 如 {"code": 0,"msg": "","data": [{}, {}]}
 */
public class JsonResult extends HashMap<String, Object> implements Serializable {
    private static final long serialVersionUID = 1L;
    /**
     * 成功
     */
    private static final int SUCCESS = 200;
    /**
     * 失败
     */
    private static final int FAIL = 1;
    /**
     * 错误
     */
    private static final int ERROR = 2;
    /**
     * 未登录
     */
    private static final int LOGOUT = 1001;

    /**
     * 构造器
     * @param code 状态码
     * @param msg 提示消息
     * @param data 数据
     */
    public JsonResult(int code, String msg, Object data) {
        // 继承自 Map，设置初始容量
        super(3);
        // 状态码，layui 中 code=0 表示成功
        this.put("code", code);
        // 提示消息
        this.put("msg", msg);
        // 数据体
        this.put("data", data);
    }
    /**
     * 构造器
     * @param code 状态码
     * @param msg 提示消息
     */
    public JsonResult(int code, String msg) {
        // 状态码
        this.put("code", code);
        // 提示消息
        this.put("msg", msg);
    }

    /**
     * 一般返回 code、msg 和 data 这三个即可，但 layui 加载 table 时还要求 count 值
     * 添加额外的返回值
     * @param key 额外信息 - key
     * @param value 额外信息 - value
     * @return 返回 额外信息
     */
    @Override
    public JsonResult put(String key, Object value) {
        super.put(key, value);
        return this;
    }


    /**
     * 快速返回请求成功
     * @param data 数据
     * @return 快速返回请求成功
     */
    public static JsonResult success(Object data) {
        return new JsonResult(SUCCESS, "ok", data);
    }

    /**
     * 快速返回请求失败
     * @param msg 提示消息
     * @return 快速返回请求失败
     */
    public static JsonResult fail(String msg) {
        return new JsonResult(FAIL, msg, null);
    }

    /**
     * 快速返回请求错误
     * @param msg 提示消息
     * @param data 数据
     * @return 快速返回请求失败
     */
    public static JsonResult error(String msg, Object data) {
        return new JsonResult(ERROR, msg, data);
    }
    /**
     * 快速返回请求错误 - 自定义状态码和错误信息
     * @param code 状态码
     * @param msg 提示消息
     * @return 快速返回请求错误 - 自定义状态码和错误信息
     */
    public static JsonResult error(int code, String msg) {
        return new JsonResult(code, msg);
    }

    /**
     * 快速返回未登录
     * @return 快速返回未登录
     */
    public static JsonResult logout() {
        return new JsonResult(LOGOUT, "未登录", null);
    }

    /**
     * 快速生成一个 Map 键值对
     * @param key 额外信息 - key
     * @param value 额外信息 - value
     * @return 快速生成一个 Map 键值对
     */
    public static Map<String, Object> fastMap(String key, Object value) {
        Map<String, Object> data = new HashMap<>(1);
        data.put(key, value);
        return data;
    }
}
```


## 2、修改后的 JsonResult 返回类

### ①、普通的写法

```java
package com.yuehai.tool.utils;


import java.io.Serializable;

/**
 * 通用的 JSON 返回结果类，用于封装操作结果
 *
 * @param <T> 数据类型的泛型参数
 * @author 月海
 * @date 2024/4/15 15:37
 * @description 通用的 JSON 返回结果类，用于封装操作结果
 */
public class JsonResult<T> implements Serializable {
    /**
     * 操作成功或失败的状态码
     */
    private int code;
    
    /**
     * 消息内容，用于提供给前端的操作结果信息
     */
    private String message;
    
    /**
     * 携带的数据，可以是任何类型的对象
     */
    private T data;
    
    public int getCode() {
        return code;
    }
    
    public void setCode(int code) {
        this.code = code;
    }
    
    public String getMessage() {
        return message;
    }
    
    public void setMessage(String message) {
        this.message = message;
    }
    
    public T getData() {
        return data;
    }
    
    public void setData(T data) {
        this.data = data;
    }
    
    /**
     * 默认构造方法，用于反序列化时创建对象
     */
    public JsonResult() {
    }
    
    /**
     * 构造方法，用于创建 JsonResult 对象
     *
     * @param code 操作成功或失败的状态码
     * @param message 消息内容，用于提供给前端的操作结果信息
     * @param data 携带的数据，可以是任何类型的对象
     */
    public JsonResult(int code, String message, T data) {
        this.code = code;
        this.message = message;
        this.data = data;
    }
    
    /**
     * 成功时的构造方法，用于快速创建表示操作成功的 JsonResult 对象
     *
     * @param data 携带的数据，可以是任何类型的对象
     * @param <T> 数据类型的泛型参数
     * @return JsonResult<T> 返回一个表示操作成功的 JsonResult 对象
     */
    public static <T> JsonResult<T> success(T data) {
        /*
            code：200，表示从客户端发来的请求在服务器端被正确处理
            message：OK，表示从客户端发来的请求在服务器端被正确处理
            data：携带的数据，可以是任何类型的对象
         */
        return new JsonResult<>(200, "OK", data);
    }
    
    /**
     * 成功时的构造方法，用于快速创建表示操作成功的 JsonResult 对象，可以自定义消息内容
     *
     * @param message 消息内容，用于提供给前端的操作结果信息
     * @param data 携带的数据，可以是任何类型的对象
     * @param <T> 数据类型的泛型参数
     * @return JsonResult<T> 返回一个表示操作成功的 JsonResult 对象
     */
    public static <T> JsonResult<T> success(String message, T data) {
        /*
            code：200，表示从客户端发来的请求在服务器端被正确处理
            message：自定义消息内容，用于提供给前端的操作结果信息
            data：携带的数据，可以是任何类型的对象
         */
        return new JsonResult<>(200, message, data);
    }
    
    /**
     * 失败时的构造方法，用于快速创建表示操作失败的 JsonResult 对象
     *
     * @param <T> 数据类型的泛型参数
     * @return JsonResult<T> 返回一个表示操作失败的 JsonResult 对象
     */
    public static <T> JsonResult<T> failure() {
        /*
            code：500，表示服务器内部错误
            message：Internal Server Error，表示服务器内部错误
            data：null，表示没有携带数据
         */
        return new JsonResult<>(
                500,
                "内部服务器错误",
                null
        );
    }
    
    /**
     * 失败时的构造方法，用于快速创建表示操作失败的 JsonResult 对象，可以自定义状态码和消息内容
     *
     * @param code 状态码
     * @param message 消息内容，用于提供给前端的操作结果信息
     * @param <T> 数据类型的泛型参数
     * @return JsonResult<T> 返回一个表示操作失败的 JsonResult 对象
     */
    public static <T> JsonResult<T> failure(int code, String message) {
        /*
            code：自定义状态码
            message：自定义消息内容，用于提供给前端的操作结果信息
            data：null，表示没有携带数据
         */
        return new JsonResult<>(code, message, null);
    }
    
    /**
     * 失败时的构造方法，用于快速创建表示操作失败的 JsonResult 对象，可以自定义状态码、消息内容和携带的数据
     *
     * @param code 状态码
     * @param message 消息内容，用于提供给前端的操作结果信息
     * @param data 携带的数据，可以是任何类型的对象
     * @param <T> 数据类型的泛型参数
     * @return JsonResult<T> 返回一个表示操作失败的 JsonResult 对象
     */
    public static <T> JsonResult<T> failure(int code, String message, T data) {
        /*
            code：自定义状态码
            message：自定义消息内容，用于提供给前端的操作结果信息
            data：自定义携带的数据，可以是任何类型的对象
         */
        return new JsonResult<>(code, message, data);
    }
}
```

### ②、需要 java 14 或以上的版本的写法

```java
package com.yuehai.test.utils;

/**
 * @author 月海
 * @date 2022/9/20 15:20
 * @description 使用 @RestController 或 @ResponseBody 时，可直接返回该对象，
 * Spring Boot 默认使用 Jackson 会自动将该对象转换为 json 字符串
 * record 是 Java 14 新增的特性，用于创建不可变的数据类，会自动创建构造方法、getter、equals、hashCode、toString 方法
 * @param success 成功标识
 * @param message 消息内容，用于提供给前端的操作结果信息
 * @param data    携带的数据，可以是任何类型的对象
 */
public record JsonResult(Boolean success, String message, Object data) {
    /**
     * 静态工厂方法，用于快速创建表示操作成功的 JsonResult 对象
     * @param data 携带的数据，可以是任何类型的对象
     * @return JsonResult 对象
     */
    public static JsonResult success(Object data) {
        return new JsonResult(true, "操作成功", data);
    }

    /**
     * 静态工厂方法，用于快速创建表示操作成功的 JsonResult 对象，传入自定义成功消息
     * @param message 消息内容，用于提供给前端的操作结果信息
     * @param data    携带的数据，可以是任何类型的对象
     * @return JsonResult 对象
     */
    public static JsonResult success(String message, Object data) {
        return new JsonResult(true, message, data);
    }

    /**
     * 静态工厂方法，用于快速创建表示操作失败的 JsonResult 对象，不传入消息
     * @return JsonResult 对象
     */
    public static JsonResult failure() {
        return new JsonResult(false, "操作失败", null);
    }

    /**
     * 静态工厂方法，用于快速创建表示操作失败的 JsonResult 对象
     * @param message 消息内容，用于提供给前端的操作结果信息
     * @return JsonResult 对象
     */
    public static JsonResult failure(String message) {
        return new JsonResult(false, message, null);
    }
}
```

## 3、

## 4、

# 三、功能实现

## 1、java 执行 HTTP 连接

### ①、配置文件

```yaml
# yaml 配置文件
spring:
  datasource:
    # 连接信息一定要用双引号引起来
    # characterEncoding=UTF-8：指定所处理字符的解码和编码的格式
    # useSSL=false：不进行 SSL 连接
    # allowPublicKeyRetrieval=true：允许恶意代理执行MITM攻击以获取明文密码，因此它在默认情况下为False，必须显式启用
    # serverTimezone=GMT：格林尼治标准时间
    url: "jdbc:mysql://172.20.2.55:3335/edu-trhpir-c?characterEncoding=UTF-8&useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=GMT"
    username: "root"
    password: "123456"
    # 数据库驱动名
    driver-class-name: com.mysql.cj.jdbc.Driver

# 配置 MyBatis 规则
mybatis:
  # sql 映射文件位置
  mapper-locations: "classpath:mappers/*.xml"
  configuration:
    # 是否开启自动驼峰命名规则映射
    map-underscore-to-camel-case: true
    # 开启 mybatis 的 sql 执行日志打印，可以在控制台打印输出 sql 语句
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl

# 配置端口号
server:
  port: 8080

# 通用 mapper 配置
mapper:
  # 在进行数据库操作的时候，判断一个属性是否为空的时候，是否需要自动追加不为空字符串的判断；如：username != null 不需要 username != ''
  not-empty: false

# CGI 属性配置
CGI:
  CGI: "http://172.20.2.55:9033/~trial/TRHPIR/CGI/WEB_TRHPIR.CGI"
  Download: "http://172.20.2.55:9033/~trial/TRHPIR/DOWNLOAD/"
```

### ②、java 代码

```java
package com.trial.edutrhpircback.utils;

import lombok.Data;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;

/**
 * @author 月海
 * @create 2022/10/12 15:24
 */

@Component
@Data
public class CGIUtil {
    // SEARCH 调用 CGI
    @Value("${CGI.CGI}")
    public String CGI;
    // 下载路径
    @Value("${CGI.Download}")
    public String Download;

    public String UTF8 = "UTF-8";

    /**
     * get 请求
     * @param param 参数
     * @return 响应数据
     * @throws IOException
     */
    public String getCgi(String param) {
        // 接收返回的数据
        StringBuilder result = new StringBuilder();

        HttpURLConnection connection = null;
        InputStream inputStream = null;
        BufferedReader bufferedReader = null;

        try {
            // 创建连接
            URL url = new URL(CGI + "?" + param);
            connection = (HttpURLConnection) url.openConnection();
            // 设置请求方式
            connection.setRequestMethod("GET");
            // 设置连接超时时间
            connection.setReadTimeout(15000);

            // 开始连接
            connection.connect();

            // 获取响应数据
            if ( connection.getResponseCode() == 200 ){
                // 获取返回的数据
                inputStream = connection.getInputStream();
                if (null != inputStream){
                    bufferedReader = new BufferedReader(new InputStreamReader(inputStream, UTF8));
                    String temp = null;
                    while (null != (temp = bufferedReader.readLine())){
                        result.append(temp).append("\r\n");
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 关闭资源
            if (null != bufferedReader){
                try {
                    bufferedReader.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (null != inputStream){
                try {
                    inputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

            if (null != connection){
                // 关闭连接
                connection.disconnect();
            }
        }
        // 返回接收的数据
        return result.toString();
    }

    /**
     * post 请求
     * @param param 参数
     * @return 响应数据
     * @throws IOException
     */
    public String postCgi(String param) {
        // 接收返回的数据
        StringBuilder result = new StringBuilder();

        HttpURLConnection connection = null;
        DataOutputStream dataOutputStream = null;
        InputStream inputStream = null;
        BufferedReader bufferedReader = null;
        try {
            // 创建连接
            URL url = new URL(CGI);
            connection = (HttpURLConnection) url.openConnection();
            // 设置请求方式
            connection.setRequestMethod("POST");
            // 设置连接超时时间
            connection.setConnectTimeout(15000);
            //设置读取超时时间
            connection.setReadTimeout(15000);

            // 设置是否可读取；doOutput 设置是否向httpUrlConnection输出
            connection.setDoOutput(true);
            //  doInput 设置是否从httpUrlConnection读入，发送post请求必须设置这两个
            connection.setDoInput(true);

            //设置通用的请求属性
            connection.setRequestProperty("accept", "*/*");
            connection.setRequestProperty("connection", "Keep-Alive");
            connection.setRequestProperty("user-agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)");
            connection.setRequestProperty("Content-Type", "application/json;charset=utf-8");

            // 设置权限
            // 设置请求头等

            // 开启连接；建立TCP连接，getOutputStream 会隐含的进行connect，所以此处可以不要
            // 创建输入输出流,用于往连接里面输出携带的参数
            dataOutputStream = new DataOutputStream(connection.getOutputStream());
            // 设置参数
            dataOutputStream.write(param.getBytes(UTF8));
            dataOutputStream.flush();
            dataOutputStream.close();

            // 获取响应数据
            if ( connection.getResponseCode() == 200 ){
                // 获取返回的数据
                inputStream = connection.getInputStream();
                if (null != inputStream){
                    bufferedReader = new BufferedReader(new InputStreamReader(inputStream, UTF8));
                    String temp = null;
                    while (null != (temp = bufferedReader.readLine())){
                        result.append(temp).append("\r\n");
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 关闭资源
            if (null != bufferedReader){
                try {
                    bufferedReader.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (null != inputStream){
                try {
                    inputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (null != dataOutputStream){
                try {
                    dataOutputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (null != connection){
                // 关闭连接
                connection.disconnect();
            }
        }
        // 返回接收的数据
        return result.toString();
    }


}

```

## 2、java 使用 ssh 连接 linux 执行命令

### ①、maven

```xml
<!-- ssh -->
<dependency>
    <groupId>ch.ethz.ganymed</groupId>
    <artifactId>ganymed-ssh2</artifactId>
    <version>262</version>
</dependency>
```

### ②、代码

```java
package com.trial.edutrhpircback.utils;

import ch.ethz.ssh2.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.util.StreamUtils;


import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletResponse;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.*;

/**
 * @author 月海
 * @create 2022/9/21 13:18
 */

@Data
@NoArgsConstructor
@Slf4j
@Component
public class SSHCommandutil {

    public static final String IP = "172.20.2.55";
    public static final String USERNAME = "creat";
    public static final String USERPWD = "creat1234";

    /**
     * 远程登录 linux 的主机；接收会话信息
     * @param conn
     * @return
     */
    public Boolean login(Connection conn) {
        boolean flg = false;

        // 连接
        try {
            conn.connect();
        } catch (IOException e) {
            conn.close();
            e.printStackTrace();
        }
        // 认证
        try {
            flg = conn.authenticateWithPassword(USERNAME, USERPWD);
        } catch (IOException e) {
            conn.close();
            e.printStackTrace();
        }

        return flg;
    }

    // 远程执行 shll 脚本或者命令
    public StringBuilder execute(String... args) {
        StringBuilder buffer = null;
        Session session = null;

        // 创建会话信息，传递给 login 方法
        Connection conn = new Connection(IP);
        if (login(conn)){

            try {
                // 打开一个会话
                session = conn.openSession();
                // 建立虚拟终端
                session.requestPTY("bash");
            } catch (IOException e) {
                e.printStackTrace();
            }

            // 打开一个Shell
            try {
                session.startShell();
            } catch (IOException e) {
                e.printStackTrace();
            }

            // 准备输入命令
            PrintWriter out = new PrintWriter(session.getStdin());
            // 输入待执行命令
            out.println("cd /home/creat/workspace/trhpir_c_pj");
            out.println("make");
            // 遍历传入的可变参数，循环执行命令
            for (String cmd : args) {
                out.println(cmd);
            }
            // 关闭 linux 端的会话
            out.println("exit");
            out.flush();

            // 关闭输入流
            out.close();

            // 调用方法，得到返回结果
            buffer = processStdout(session.getStdout());
        }

        // 关闭会话
        session.close();
        conn.close();

        return buffer;
    }

    // 解析脚本执行返回的结果集，以纯文本的格式返回
    private StringBuilder processStdout(InputStream in) {
        // 定义接收数据的字符串
        StringBuilder buffer = new StringBuilder();

        // 包装输入流
        BufferedReader br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));

        // 创建线程，定义线程数为 1
        ExecutorService es = Executors.newFixedThreadPool(1);
        // Future用于执行多线程的执行结果
        BufferedReader finalBr = br;
        Future future = es.submit( () -> {
            String line;
            try {
                while ( (line = finalBr.readLine()) != null){
                    // 将传输过来的参数赋值给 buffer
                    buffer.append(line + "\n");
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        } );

        // 线程运行时间为一秒，超时退出
        try {
            future.get(1, TimeUnit.SECONDS);
        } catch (Exception e) {
            System.out.println("数据抽出完成，退出线程，关闭会话");
        }

        return buffer;
    }

    // 下载文件
    public void getFile(String filePath, HttpServletResponse response) {
        // 创建会话信息，传递给 login 方法
        Connection conn = new Connection(IP);
        if (login(conn)){
            try {
                SCPClient scpClient = conn.createSCPClient();
                // 读取文件
                SCPInputStream scpInputStream = scpClient.get(filePath);

                byte[] bytes = StreamUtils.copyToByteArray(scpInputStream);

                // 文件名
                String fileName = "1111.xlsx";

                response.reset();
                response.setContentType("application/octet-stream");
                response.addHeader("Content-Disposition", "attachment;fileName=" + new String(fileName.getBytes(StandardCharsets.UTF_8), StandardCharsets.ISO_8859_1));
                response.addHeader("Content-Length", "" + bytes.length);

                ServletOutputStream outputStream = response.getOutputStream();
                outputStream.write(bytes);
                outputStream.flush();
            } catch (IOException e) {
                e.printStackTrace();
            }

        }

    }
}
```

## 3、将 `url` 中的特殊字符解码

1. `url` 字符串：`%7B%22name%22%3A%22userid%22%2C%22value%22%3A%2210222148%22%2C%22expires%22%3A1%2C%22path%22%3A%22%2F%22%7D`
2. 解码后：`{"name":"userid","value":"10222148","expires":1,"path":"/"}`

```javascript
package com.yuehai;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;

/**
 * @author 月海
 * @create 2022/12/8 8:19
 */

@SpringBootTest
class URLDecoderDecode {

    @Test
    void test01() throws UnsupportedEncodingException {
        String str = "%7B%22name%22%3A%22userid%22%2C%22value%22%3A%2210222148%22%2C%22expires%22%3A1%2C%22path%22%3A%22%2F%22%7D";

        // 将url 编码解码： {"name":"userid","value":"10222148","expires":1,"path":"/"}
        String decode = URLDecoder.decode(str, "UTF-8");

        System.out.println(decode);
    }

}
```

![](https://www.yue-hai.top:10300/file/downloadFile?fullFilePath=%2Fhome%2Fyan%2F%E6%A1%8C%E9%9D%A2%2F%E5%86%85%E5%AD%98%2F%E6%96%87%E6%A1%A3%E8%B5%84%E6%96%99%2FTakeDown%2Fjava%2Fattachments%2FPasted%20image%2020230725131943.png)

## 4、


# 四、框架使用

## 1、fastjson

### ①、使用 `fastjson` 框架，将` json` 字符串反序列化并转为 `Map` 集合

1. 使用 `fastjson` 框架，将` json` 字符串反序列化
2. 将` json` 字符串转化为 `map` 集合

#### Ⅰ、maven

```xml
<!-- https://mvnrepository.com/artifact/com.alibaba.fastjson2/fastjson2 -->
<dependency>
    <groupId>com.alibaba.fastjson2</groupId>
    <artifactId>fastjson2</artifactId>
    <version>2.0.20</version>
</dependency>
```

#### Ⅱ、代码

```java
package com.yuehai;

import com.alibaba.fastjson2.JSON;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.util.Map;
import java.util.function.BiConsumer;

/**
 * @author 月海
 * @create 2022/12/8 8:19
 */

@SpringBootTest
class URLDecoderDecode {

    @Test
    void test01() throws UnsupportedEncodingException {
        String str = "%7B%22name%22%3A%22userid%22%2C%22value%22%3A%2210222148%22%2C%22expires%22%3A1%2C%22path%22%3A%22%2F%22%7D";

        // 将url 编码解码：
        // {"name":"userid","value":"10222148","expires":1,"path":"/"}
        String decode = URLDecoder.decode(str, "UTF-8");

        // 使用 fastjson 框架，将 json 字符串反序列化：
        // {"name":"userid","value":"10222148","expires":1,"path":"/"}
        Object parse = JSON.parse(decode);
        // 将 json 字符串转化为 map 集合
        // {"name":"userid","value":"10222148","expires":1,"path":"/"}
        Map<String, Object> map = (Map<String, Object>) parse;

        // 从 map 集合中使用 key 取出值
        System.out.println("name --> "+ map.get("name"));
        System.out.println("value --> " + map.get("value"));
        System.out.println("--------------------------------");

        // Lamubda 表达式遍历
        map.forEach(new BiConsumer<String, Object>() {
            @Override
            public void accept(String key, Object value) {
                System.out.println(key + "\t --> \t" + value);

            }
        });
        System.out.println("--------------------------------");

        /**
         * 简化 Lamubda 表达式遍历
         * 化简的规则为：
         * 参数类型可以省略不写
         * 如果只有一个参数，参数类型可以省略，同时参数也可以省略
         * 如果Lamubda表达式的方法体代码只有一行代码。可以省略大括号不写，同时省略分号
         * 如果Lamubda表达式的方法体只有一行代码。可以省略大括号不写。此时，如果这行代码是 return 语句，必须省略 return 不写，同时也必须省省略分号不写
         */
        map.forEach((key, value)-> {
            System.out.println(key + "\t --> \t" + value);
        });
    }

}
```


### ②、

## 2、

## 3、

## 4、
# 五、开发环境

## 1、

## 2、

## 3、

## 4、

## 5、

## 6、

# 六、开发工具

## 1、maven

### ①、maven 父子项目设置

1. 父项目 pom.xml 文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <!-- Spring Boot 项目，所以需要继承 spring-boot-starter-parent -->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.6.11</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    
    <!-- 本项目的设置 -->
    <groupId>com.yuehai</groupId>
    <artifactId>SpringBoot_redis</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>SpringBoot_redis</name>
    <description>SpringBoot_redis</description>
    <!--  packaging 的默认打包类型是 jar，所有的父工程打包方式都需要设置成 pom -->
    <packaging>pom</packaging>
    
    <!-- 子项目 -->
    <modules>
        <module>01_Jedis_Test</module>
        <module>02_Jedis_VerificationCode</module>
        <module>03_redis_SpringBoot</module>
    </modules>

    <!-- jdk 版本 -->
    <properties>
        <java.version>1.8</java.version>
    </properties>

    <!-- 依赖配置：目前这里的配置的依赖所引入的jar包在此工程下的所有子工程都会被引入 -->
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
    
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <!-- maven 插件 -->
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.1</version>
                <configuration>
                    <source>1.8</source>
                    <target>1.8</target>
                    <encoding>UTF-8</encoding>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>

```


2. 子项目 pom.xml 文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <!-- 指定继承的父项目 -->
    <parent>
        <!-- 父项目：groupId 组 -->
        <groupId>com.yuehai</groupId>
        <!-- 父项目：artifactId 名 -->
        <artifactId>SpringBoot_redis</artifactId>
        <!-- 父项目：version 版本 -->
        <version>0.0.1-SNAPSHOT</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    
    <!-- 本项目的设置 -->
    <artifactId>redis_SpringBoot</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>03_redis_SpringBoot</name>
    <description>03_redis_SpringBoot</description>
    
    <!-- 本项目所需的独有依赖 -->
    <dependencies>
        <!-- redis -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        
        <!-- spring2.X 集成 redis 所需 common-pool2 -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-pool2</artifactId>
            <version>2.11.1</version>
        </dependency>
    </dependencies>

</project>

```

### ②、解决 Maven 项目中模块灰色显示的问题

- Maven 项目中模块灰色显示的问题

![](https://www.yue-hai.top:10300/file/downloadFile?fullFilePath=%2Fhome%2Fyan%2F%E6%A1%8C%E9%9D%A2%2F%E5%86%85%E5%AD%98%2F%E6%96%87%E6%A1%A3%E8%B5%84%E6%96%99%2FTakeDown%2Fjava%2Fattachments%2F02、Maven项目中模块灰色显示的问题.png)

- 解决：

![](https://www.yue-hai.top:10300/file/downloadFile?fullFilePath=%2Fhome%2Fyan%2F%E6%A1%8C%E9%9D%A2%2F%E5%86%85%E5%AD%98%2F%E6%96%87%E6%A1%A3%E8%B5%84%E6%96%99%2FTakeDown%2Fjava%2Fattachments%2F03、Maven项目中模块灰色显示的问题2.png)

### ③、依赖版本号提取

1. 在 `properties` 标签中自定义标签，写入版本号
2. 在对应依赖的版本号标签中使用 `$` 引入
3. 示例：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	
	<!-- Maven 项目模型版本 -->
	<modelVersion>4.0.0</modelVersion>
	<!-- 继承自 Spring Boot 的父项目配置 -->
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.2.3</version>
		<!-- 从仓库中查找父项目 -->
		<relativePath/>
	</parent>
	
	<!-- 项目的 groupId，一般为项目的包名 -->
	<groupId>com.yuehai.chat</groupId>
	<!-- 项目的 artifactId，一般为项目的名称 -->
	<artifactId>y-chat-back-server</artifactId>
	<!-- 项目的版本号 -->
	<version>1.0-SNAPSHOT</version>
	<!-- 项目的名称 -->
	<name>y-chat-back-server</name>
	<!-- 项目的描述 -->
	<description>y-chat-back-server</description>
	
	<!-- 配置项目的属性 -->
	<properties>
		<!-- Java 源代码的版本 -->
		<maven.compiler.source>21</maven.compiler.source>
		<!-- 编译后的字节码的目标 Java 版本 -->
		<maven.compiler.target>21</maven.compiler.target>
		<!-- 项目源代码的编码格式 -->
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		
		<!-- Druid 版本 -->
		<druid.version>1.2.21</druid.version>
	</properties>
	
	<!-- 项目的依赖 -->
	<dependencies>
		<!-- 包含了 Spring Boot 应用所需的基本依赖 -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter</artifactId>
		</dependency>
		
		<!-- Spring Boot 的 Web 启动器，用于开发 Web 应用 -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		
		<!-- MySQL 数据库的 JDBC 驱动 -->
		<dependency>
			<groupId>com.mysql</groupId>
			<artifactId>mysql-connector-j</artifactId>
			<scope>runtime</scope>
		</dependency>
		
		<!-- Druid 数据库连接池 -->
		<dependency>
			<groupId>com.alibaba</groupId>
			<artifactId>druid-spring-boot-starter</artifactId>
			<version>${druid.version}</version>
		</dependency>
		
		<!-- lombok 依赖，用于简化代码 -->
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
		</dependency>
	</dependencies>

</project>
```

### ④、自己下载 jar 包放到本地 maven 仓库中

> 这么做的原因：[maven 仓库](https://mvnrepository.com/) 中有这个类，但是项目 pom 文件中爆红，无法下载
> 
> 以 [modelmapper](https://mvnrepository.com/artifact/org.modelmapper/modelmapper) 为例

1. 在 [maven 仓库](https://mvnrepository.com/) 中搜索 modelmapper，点击进入

![|351](https://www.yue-hai.top:10300/file/downloadFile?fullFilePath=%2Fhome%2Fyan%2F%E6%A1%8C%E9%9D%A2%2F%E5%86%85%E5%AD%98%2F%E6%96%87%E6%A1%A3%E8%B5%84%E6%96%99%2FTakeDown%2Fjava%2Fattachments%2FPasted%20image%2020240507081955.png)

2. 选择版本

![|700](https://www.yue-hai.top:10300/file/downloadFile?fullFilePath=%2Fhome%2Fyan%2F%E6%A1%8C%E9%9D%A2%2F%E5%86%85%E5%AD%98%2F%E6%96%87%E6%A1%A3%E8%B5%84%E6%96%99%2FTakeDown%2Fjava%2Fattachments%2FPasted%20image%2020240507082040.png)

3. 点击下载 jar 包

![|700](https://www.yue-hai.top:10300/file/downloadFile?fullFilePath=%2Fhome%2Fyan%2F%E6%A1%8C%E9%9D%A2%2F%E5%86%85%E5%AD%98%2F%E6%96%87%E6%A1%A3%E8%B5%84%E6%96%99%2FTakeDown%2Fjava%2Fattachments%2FPasted%20image%2020240507082109.png)

4. 点击 maven 中的 pom，会进入一个新页面，右键另存为，下载

![|700](https://www.yue-hai.top:10300/file/downloadFile?fullFilePath=%2Fhome%2Fyan%2F%E6%A1%8C%E9%9D%A2%2F%E5%86%85%E5%AD%98%2F%E6%96%87%E6%A1%A3%E8%B5%84%E6%96%99%2FTakeDown%2Fjava%2Fattachments%2FPasted%20image%2020240507082741.png)

![|700](https://www.yue-hai.top:10300/file/downloadFile?fullFilePath=%2Fhome%2Fyan%2F%E6%A1%8C%E9%9D%A2%2F%E5%86%85%E5%AD%98%2F%E6%96%87%E6%A1%A3%E8%B5%84%E6%96%99%2FTakeDown%2Fjava%2Fattachments%2FPasted%20image%2020240507083147.png)

5. 将下载的 `modelmapper-3.2.0.pom.xml` 改名为 `modelmapper-3.2.0.pom`
6. 将下载的 jar 包和 pom 文件放到：`本地 maven 仓库目录\org\modelmapper\modelmapper\3.2.0` 中

![](https://www.yue-hai.top:10300/file/downloadFile?fullFilePath=%2Fhome%2Fyan%2F%E6%A1%8C%E9%9D%A2%2F%E5%86%85%E5%AD%98%2F%E6%96%87%E6%A1%A3%E8%B5%84%E6%96%99%2FTakeDown%2Fjava%2Fattachments%2FPasted%20image%2020240507083426.png)

7. 打开 idea 进入项目，打开控制台，执行命令：

```shell
# 命令
mvn install:install-file -Dfile=路径到你的jar文件 -DpomFile=路径到你的pom.xml文件

# 示例
mvn install:install-file -Dfile=D:\java\Apache\Maven\Repository\org\modelmapper\modelmapper\3.2.0\modelmapper-3.2.0.jar -DpomFile=D:
\java\Apache\Maven\Repository\org\modelmapper\modelmapper\3.2.0\modelmapper-3.2.0.pom 
```

8. 命令执行完成后，依赖不再爆红

### ⑤、

### ⑥、

## 2、tomcat

### ①、直接启动 Tomcat 控制台乱码

1. 问题：控制台乱码：

![|700](https://www.yue-hai.top:10300/file/downloadFile?fullFilePath=%2Fhome%2Fyan%2F%E6%A1%8C%E9%9D%A2%2F%E5%86%85%E5%AD%98%2F%E6%96%87%E6%A1%A3%E8%B5%84%E6%96%99%2FTakeDown%2Fjava%2Fattachments%2FPasted%20image%2020231220085046.png)

2. 原因：这是由于 windows 下的 cmd 的默认编码是 `GBK` 编码，Tomcat 控制台默认输出设置为 `UTF-8` 编码
3. 解决方法：
	1. 修改 CMD 命令行的编码格式为 `UTF-8`
	2. 将 tomcat 控制台日志输出编码格式更改为 `GBK`；修改 tomcat 根目录下 `conf/logging.properties` 文件中的 `ConsoleHandler.encoding=utf-8`，这种方式能解决 cmd 控制台中文乱码，但不建议使用。因为更改了 tomcat 默认编码，如果我们使用idea 启动 tomcat，idea 的默认编码不是 GBK，就会同样产生 idea 控制台下 tomcat 乱码问题
4. 1
5. 1

### ②、Idea 中 Tomcat 控制台乱码

- Tomcat 设置中的虚拟机设置中加入如下代码：

```java
	-Dfile.encoding=UTF-8
```

### ③、

## 3、

## 4、

## 5、

# 七、

# 八、

# 九、

# 十、

# 十一、

# 十二、

# 十三、

# 十四、

# 十五、

# 十六、

# 十七、

# 十八、

# 十九、

# 二十、

## 1、
## 2、
## 3、
## 4、
## 5、
## 6、
## 7、
## 8、
## 9、

---

### ①、
### ②、
### ③、
### ④、
### ⑤、
### ⑥、
### ⑦、
### ⑧、
### ⑨、
### ⑩、
#### Ⅰ、
#### Ⅱ、
#### Ⅲ、
#### Ⅳ、
#### Ⅴ、
#### Ⅵ、
#### Ⅶ、
#### Ⅷ、
#### Ⅸ、
#### Ⅹ、
